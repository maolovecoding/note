#                                     希尔排序算法

#### 希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。

前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组 元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真 正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到 更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数， 这样的需求如何实现呢？接下来我们来看看希尔排序的原理。

需求：

 排序前：{9,1,2,5,7,4,8,6,3,5}
  排序后：{1,2,3,4,5,5,6,7,8,9}
排序原理：

 1.选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；
  2.对分好组的每一组数据完成插入排序；

 3.减小增长量，小减为1，重复第二步操作。

增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则：

```Java
int N = a.length;
//确定增长量h的最大值
int h = 1;
while (h < N / 2) {
    h = 2 * h + 1;
}
```

### 代码实现

```Java
public class Shell {
    /**
     * 对数组中的元素进行排序
     *
     * @param a
     */
    public static void sort(Comparable[] a) {
        int N = a.length;
        //确定增长量h的最大值
        int h = 1;
        while (h < N / 2) {
            h = 2 * h + 1;
        }
        //当增长量h小于1时，排序结束
        while (h >= 1) {
            //找到待插入的元素
            for (int i = h; i < N; i++) {
                //a[i]就是待插入的元素
                //把待插入的元素插入到有序数列中
                for (int j = i; j >= h; j -= h) {
                    //待插入的元素是a[j],比较a[j]和a[j-h]
                    if (greater(a[j - h], a[j])) {
                        exch(a, j - h, j);
                    } else {
                        //待插入元素找到了合适位置
                        break;
                    }
                }
            }
            //减小h的值
            h = h / 2;
        }
    }

    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) > 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### 测试代码

```Java
public class ShellTest {
    public static void main(String[] args) {
        Integer[] a = {2,5,1,8,2,9,3,4,6,0};
        Shell.sort(a);
        System.out.println(Arrays.toString(a));//[0, 1, 2, 2, 3, 4, 5, 6, 8, 9]
    }
}
```

### 希尔排序的时间复杂度分析

在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是 好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。
我们可以使用事后分析法对希尔排序和插入排序做性能比较。
测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个 时间的时间差就是排序的耗时。