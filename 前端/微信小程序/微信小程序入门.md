# 微信小程序入门(一)



## 项目结构解读

![image-20210823172509428](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210823172509428.png)

**我们发现，页面页面一般有4个文件组成**

### 每个文件的功能

#### xxx.js(index.js)文件

该文件完成业务逻辑的书写。

#### xxx.json(index.json)

该文件用来进行一些页面的配置。**有些时候我们不需要书写样式等代码，而是在json文件里面进行一定的配置，就可以达到我们想要的效果。比如：我们修改一下顶部导航栏的颜色，就可以在JSON文件里面配置。这种配置机制在我们前端的开发中不常见。**

![image-20210823173430156](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210823173430156.png)



#### xxx.wxml(index.wxml)

该文件用来书写页面的骨架。类似于html。



#### xxx.wxss(index.wxss)

该文件用来书写页面的样式。类似于css。



#### 总结

**其实，这四个文件并不都是必须都要存在的，比如我们的页面每页样式，那么wxss文件就不是必须的。所以说，除了页面的骨架wxml，其他文件都不是必须的。**



#### 文件约定

如果我们这个页面的四个文件的**名称相同（后缀不同）**，都是index.后缀的文件，那么我们文件之间的相互调用是不需要进行导入的。而是可以直接使用其他文件的内容。

**综上所述：我们建立一个新的页面最好也采用这种约定速成的方式。**

![image-20210823194921750](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210823194921750.png)



## 文档结构解读

![image-20210823195321883](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210823195321883.png)

**文件app.js,app.json,app.wxss**这三个文件的名称是不能修改的。作用和上面相同文件类型的作用一样。但是这三个文件可以控制整个微信小程序（也就是应用程序级别的）的样式和业务逻辑等。而上面介绍的文件只能控制所属的页面。

**虽然这三个文件配置的样式等是全局的，但是如果配置的全局样式和局部样式有冲突，以页面的局部样式为主。**

![image-20210823201416273](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210823201416273.png)





**文件project.config.json是用来记录当前项目的配置，设置的。**

**sitemap.json是来做微信小程序搜索的。暂时不做了解。**



## 小程序入门

### 删除项目结构

首先我们删除项目中的其他文件，只保留 **project.config.json，sitemap.json**这两个文件

![image-20210824194736652](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824194736652.png)

### 小程序页面的搭建技巧和规则

**当我们删除项目结构，只保留这两个文件以后，发现在调试区域会报错。提醒我们没有app.json文件。**

![image-20210824194937369](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824194937369.png)

上面我们说过，app.json文件是在微信小程序开发项目中，必须存在的文件。

#### 新建app.json

1. 新建json文件以后，会提醒我们json文件不能为空

![image-20210824195055273](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824195055273.png)

2. 写一个空的花括号以后，会报错提醒我们，必须有pages属性，且pages属性必须为数组。（页面肯定不止一个，注意：json文件里面不可写注释。小程序的页面**只有在app.json里面注册**以后才能被访问。）

![image-20210824195147707](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824195147707.png)

3. 有该属性后，一样报错。很明显，找不到页面。

   ![image-20210824195611804](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824195611804.png)

4. 新建页面，新建pages文件夹，在下面再建index文件夹。我们知道了每个页面都有四个文件，但是我们需要一个个新建吗？不需要的。只需要邮件单击index文件夹，然后点新建page，填写文件名称即可，不需要写后缀，自动帮我们建好四个文件。且在app.json文件的pages属性里面完成了页面的注册。

   ![image-20210824195817986](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824195817986.png)

   ![image-20210824195918872](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824195918872.png)

**注意：页面文件只需要写index，小程序会默认帮我们找到名称为index的四个文件。**且小程序的默认首页就是第一个注册的页面。

**例如，我们在新建一个welcome页面，并将其第一个注册，放在index页面前面，发现默认页面就是welcome了**

![image-20210824200448529](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824200448529.png)

### 小程序必备语法

#### 1. 如何显示一张图片

**我们指知道，在html中，可以使用img标签来显示图片，在小程序中，我们使用的是`<image></image>`**标签。使用src属性引用图片。

#### 2. 文本

使用`<text></text>`标签包裹我们想要显示的文字。

#### 3. 按钮

和html一样，都是使用`<button></button>`标签

![image-20210824205741605](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824205741605.png)

![image-20210824205801133](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824205801133.png)

**我们发现：这个头像是椭圆形的，而实际上我们的头像图片是圆形的。为什么默认情况变成的椭圆形？思考一下**

![image-20210824205924061](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824205924061.png)



#### 单位rpx

我们在微信小程序里面，设置样式的时候，推荐使用rpx单位，而不是px单位。

因为：**单位：rpx 会自适应屏幕的尺寸等，给我们一种很舒服的视觉体验，换了机型会自适应大小**。而使用px为单位，就会固定死大小，即使切换了机型，分辨率发生了改变，大小也不会改变。

```html
<!-- 1. 显示图片的标签 -->
<!-- 可以使用相对路径，也可以使用绝对路径 -->
<!-- 单位：rpx 会自适应屏幕的尺寸等，给我们一种很舒服的视觉体验，换了机型会自适应大小 -->
<image src="/images/avatar/1.webp" style="width:220rpx;height:220rpx"></image>
<!-- 2. 显示文本的标签 -->
<text>你好：听雨少年！</text>
<!-- 直接书写文本，也可以正常显示，但是我们建议还是使用text标签进行包裹，遵守规范，而且没有标签包裹，我们也难以设置样式 -->
<!-- 我也直接显示了！ -->
<!-- 按钮标签 -->
<button>我是按钮</button>
```

**当然，你也可以选择使用px为单位，但是我们需要在设置大小的时候，将数值设置为图片实际大小的1/2。这是建立在以iPhone6机型为原型图的基础上。**

![image-20210824211637841](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824211637841.png)

**回到开始的问题：头像在默认情况下为什么变成椭圆形或者不是我们图片默认的形状？**

因为：image标签（组件）有默认样式

![image-20210824212929910](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824212929910.png)

**图片建议使用png格式！！！**



### 完成第一个页面布局

#### 配置小程序导航头部样式

![image-20210824221823793](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824221823793.png)

我们觉得这种默认的样式很难看，可以在app.json文件里面配置这个头部的样式

```json
"window": {
    "navigationBarBackgroundColor": "#b3d4db"
  },
```

![image-20210824221930523](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824221930523.png)

#### 页面样式

![image-20210824222839536](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210824222839536.png)

#### 页面样式代码

```html
<!--pages/welcome/welcome.wxml-->

<!-- 使用view标签，作为最外层容器，包裹所有标签，view不是有具体含义的标签 -->
<view class="container">
<!-- 1. 显示图片的标签 -->
<!-- 可以使用相对路径，也可以使用绝对路径 -->

<image class="user-avatar" src="/images/avatar/avatar.png"></image>
<!-- 2. 显示文本的标签 -->
<text class="motto">听雨少年</text>
<!-- 直接书写文本，也可以正常显示，但是我们建议还是使用text标签进行包裹，遵守规范，而且没有标签包裹，我们也难以设置样式 -->
<!-- 我也直接显示了！ -->
<!-- 按钮标签 -->
<!-- 官方的提供的按钮我们一般不推荐使用，因为样式等问题很难修正 -->
<!-- <button>我是按钮</button> -->

<!-- 这里使用view模拟一个button组件 -->
<view class="btn-journey-container">
  <!-- 设置样式模拟出我们喜欢的按钮样式 -->
  <text class="journey">开启小程序之旅</text>
</view>

</view>
```

```css
/* pages/welcome/welcome.wxss */

/* 单位：rpx 会自适应屏幕的尺寸等，给我们一种很舒服的视觉体验，换了机型 会自适应大小 */
/* 顶层容器page，设置背景色 */
page {
  background-color: #b3d4db;
}

/* 外层容器 */
.container {
  /* 开启弹性布局 */
  display: flex;
  /* 排列方向，垂直排列 */
  flex-direction: column;
  /* 在排列方向的侧轴上居中 */
  align-items: center;
}

/* 设置头像样式 */
.user-avatar {
  width: 220rpx;
  height: 220rpx;
  border-radius: 50% 50%;
  margin-top: 160rpx;
}

/* 昵称 */
.motto {
  /* color:#666; */
  margin-top: 100px;
  font-size: 36rpx;
  font-weight: bold;
}

/* 设置模拟的按钮外边框 */
.btn-journey-container {
  margin-top: 150rpx;
  border: 1rpx solid #405f80;
  width: 200rpx;
  height: 80rpx;
  border-radius: 10px;
  /* 文字居中 */
  text-align: center;

}

/* 按钮文字 */
.journey {
  font-size: 24rpx;
  color: #405f80;
  line-height: 80rpx;
  font-weight: bold;
}
```

```css
/* app.wxss */
text{
    
  color:#666;
}
```



# 微信小程序入门(二)

## 安装组件库

**在微信小程序里面，现在也可以使用第三方的组件库。**

**这里使用的是lin-ui组件库。有需要的可以去百度官网了解一下。**

1. 在项目根目录下初始化npm

   ```shell
   npm init -y
   ```

2. 安装 **lin-ui**组件库

   ```shell
   npm install lin-ui
   ```

3. 在微信小程序的 **工具**选项下选择构建npm

   ![image-20210826140635548](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826140635548.png)

4. 构建完成够，项目下就又多出一个文件夹。我们使用组件的时候都是使用这个文件夹下的。

   ![image-20210826140736290](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826140736290.png)

5. 在每个页面使用自定义组件的时候，我们需要在页面的json配置文件中，进行配置，指定我们使用的组件名称，以及组件所在的位置。

   ![image-20210826140906964](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826140906964.png)



## 组件库的使用

### 头像组件库

**这里简单使用一下头像组件库。**

```wxml
<!-- 使用组件库 动态绑定用户的头像，昵称(绑定的语法后面再说) -->
<!-- 使用size属性可以指定大小 -->
<!-- shape属性可以指定头像的样式，圆的还是方的 -->
<!-- 使用placement 可以指定头像和昵称的排列位置，这里上下排列 -->
<m-avatar placement="bottom" size="190" shape="circle" open-data="{{['userAvatarUrl','userNickName']}}"/>
```

![image-20210826142528576](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826142528576.png)

## pages页面的开发

### 指定主页

**每次开发新的页面，总是需要在注册页面的地方频繁切换第一个文件，来达到预览的效果。比较麻烦。**

#### 方式一：

**在现在的小程序中，增加了新的功能，可以在app.json中，直接指定主页。**

![image-20210826143250347](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826143250347.png)

![image-20210826143741895](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826143741895.png)

#### 方式二：指定编译模式

![image-20210826143942233](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826143942233.png)

![image-20210826144021270](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826144021270.png)

**将页面指定为我们当前开发的页面即可。**



### 制作轮播图

#### 使用swipe

```html
<!-- 使用官方提供的swiper组件 来做轮播图 -->
  <!-- swiper 滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情 -->
  <swiper>
    <!-- 一般为了让图片撑满容器，需要设置容器的大小，和图片的大小，swipe-item 可以不设置 -->
    <swiper-item>
      <image src="/images/img1.jpg"></image>
    </swiper-item>
    <swiper-item>
      <image src="/images/img2.webp"></image>
    </swiper-item>
    <swiper-item>
      <image src="/images/img3.webp"></image>
    </swiper-item>
  </swiper>
```

```css
/* 设置轮播图的大小 */
swiper {
  width: 100%;
  height: 460rpx;
}

image {
  width: 100%;
  height: 100%;
}
```

![image-20210826153441612](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826153441612.png)

**这样就完成了轮播图最开始的状态。**

#### 轮播图的指示点和自动轮播

**我们使用swiper的某些属性就可以完成这两个功能。**

indicator-dots="true" 显示轮播图的指示点

  但是，即使我们设置 indicator-dots="false" 也就是设置属性值为false

  我们的轮播图小指示点 也不会消失，除非我们不设置这个属性，或者

  我们设置属性值为 indicator-dots="{{false}}"

  那么问题来了：**为什么我们设置属性值为 {{false}} 才能表示否定的概念呢？**

  原因是，不加双花括号，我们小程序会把这个属性值当做普通的字符串，普通的字符串在js中我们知道会转为true，这里也是一样。

  双花括号里面写false 才能表示false

  注意：关于双花括号的使用我们在后面会在说，**实际上双花括号里面的数据会被当做js中的变量或者表达式进行运算。**

只写属性值也会默认表示设置这个属性值为true。

##### 布尔属性赋值建议

所以，我们在给布尔类型的属性赋值的时候，不管是true还是false，建议都使用双花括号进行包裹。

![image-20210826162313843](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826162313843.png)

![image-20210826162335200](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826162335200.png)

#### 其他的swiper常用属性

![image-20210826163241249](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826163241249.png)

**这些属性在微信小程序的官网都是有说明的。想了解更多可以去官网自行阅读。**

[微信小程序的swiper组件的使用](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)

### 单篇文章的制作

![image-20210826172517962](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826172517962.png)

**我们要完成这样的一篇文章。我们分析一下整体的结构。**

1. 上面的轮播图我们已经制作完成了，那么就剩下文章的制作
2. 这个文章从上到下，我们可以分为五个部分
   1. 头像+日期部分
   2. 文章标题部分
   3. 文章图片
   4. 文章内容
   5. 浏览和收藏人数
3. 分为了五个部分，我们在开始制作这个文章模块。

**先分析好我们制作页面的模块结构，在书写代码效率更高。**

#### 文章结构

```html
!-- 第一篇文章 -->
  <view class="post-container">
    <!-- 第一部分 作者 日期 -->
    <view class="post-author-date">
      <!-- 头像 -->
      <image class="post-author" src="/images/avatar/1.png"></image>
      <text class="post-date">2021 08 26</text>
    </view>
    <!-- 第二部分 文章标题 -->
    <text class="post-title">2021 哈哈哈哈哈哈哈啊哈哈哈哈哈</text>
    <!-- 第三部分 -->
    <image class="post-image" src="/images/post/cat.png"></image>
    <!-- 第四部分 文章内容 -->
    <text class="post-content">滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情</text>
    <!-- 第五部分 -->
    <view class="post-like">
      <image class="post-like-image" src="/images/icon/chat.png"></image>
      <text class="post-like-font">92</text>
      <image class="post-like-image" src="/images/icon/view.png" />
      <text class="post-like-font">102</text>
    </view>
  </view>
```



#### 文章样式

```css
/* 文章样式 */
.post-container {
  /* 弹性布局 */
  display: flex;
  flex-direction: column;
  margin-top: 20rpx;
  margin-bottom: 40rpx;
  background-color: #fff;
  /* 上下边框线 */
  border-top: 1rpx solid #ededed;
  border-bottom: 1rpx solid #ededed;
  padding-bottom: 10rpx;
}

/* 作者 日期样式 */
.post-author-date {
  margin: 10rpx 0 20rpx 10rpx;
  display: flex;
  flex-direction: row;
  /* flex 布局居中方案 */
  align-items: center;
}

.post-author {
  width: 60rpx;
  height: 60rpx;
  /* 头像和文字居中 */
  /* vertical-align: middle; */

}

.post-date {
  margin-left: 20rpx;
  font-size:26rpx;
  /* vertical-align: middle; */
}

/* 文章标题 */
.post-title{
  font-size:34rpx;
  font-weight: 700;
  margin-bottom: 20rpx;
  margin-left: 20rpx;
  color:#333;
}
/* 文章主图 */
.post-image{
  width: 100%;
  height: 340rpx;
  margin-bottom: 30rpx;
}
/* 文章内容 */
.post-content{
  color:#666;
  font-size: 28rpx;
  margin-bottom: 20rpx;
  margin-left: 20rpx;
  line-height: 40rpx;
  letter-spacing: 2rpx;
  text-indent: 2em;
}
/* 文章模拟阅读量 */
.post-like{
  display: flex;
  flex-direction: row;
  margin-left: 26rpx;
  align-items: center;
}
.post-like-image{
  height: 32rpx;
  width: 32rpx;
  margin-right: 16rpx;
}
.post-like-font{
  margin-right: 40rpx;
  font-size: 26rpx;
}

```



### 整体代码

#### 页面结构

```html
<!--pages/posts/posts.wxml-->

<view>
  <!-- 使用官方提供的swiper组件 来做轮播图 -->
  <!-- swiper 滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情 -->
  <!-- 
    indicator-dots="true" 显示轮播图的指示点
    但是，即使我们设置 indicator-dots="false" 也就是设置属性值为false
    我们的轮播图小指示点 也不会消失，除非我们不设置这个属性，或者
    我们设置属性值为 indicator-dots="{{false}}"
    那么问题来了：为什么我们设置属性值为 {{false}} 才能表示否定的概念呢？
    原因是，不加双花括号，我们小程序会把这个属性值当做普通的字符串，普通的字符串在js中我们知道会转为true，这里也是一样。
    双花括号里面写false 才能表示false
    注意：关于双花括号的使用我们在后面会在说，实际上双花括号里面的数据会被当做js中的变量或者表达式进行运算。
   -->
  <!-- autoplay="true" 自动轮播 -->
  <!-- indicator-active-color="#fff" 指示点激活的颜色 -->
  <!-- circular="true"循环播放图片 -->
  <!-- interval="2000" 图片切换间隔时长 字符串的数字内部会被转型 -->
  <swiper indicator-dots="{{true}}" autoplay="true" indicator-active-color="#fff" circular="true" interval="2000">
    <!-- 一般为了让图片撑满容器，需要设置容器的大小，和图片的大小，swipe-item 可以不设置 -->
    <swiper-item>
      <image src="/images/img1.jpg"></image>
    </swiper-item>
    <swiper-item>
      <image src="/images/img2.webp"></image>
    </swiper-item>
    <swiper-item>
      <image src="/images/img3.webp"></image>
    </swiper-item>
  </swiper>

  <!-- pages -->

  <!-- 第一篇文章 -->
  <view class="post-container">
    <!-- 第一部分 作者 日期 -->
    <view class="post-author-date">
      <!-- 头像 -->
      <image class="post-author" src="/images/avatar/1.png"></image>
      <text class="post-date">2021 08 26</text>
    </view>
    <!-- 第二部分 文章标题 -->
    <text class="post-title">2021 哈哈哈哈哈哈哈啊哈哈哈哈哈</text>
    <!-- 第三部分 -->
    <image class="post-image" src="/images/post/cat.png"></image>
    <!-- 第四部分 文章内容 -->
    <text class="post-content">滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情,滑块视图容器，这个容器不仅仅是用来滑动图片，可以做很多事情</text>
    <!-- 第五部分 -->
    <view class="post-like">
      <image class="post-like-image" src="/images/icon/chat.png"></image>
      <text class="post-like-font">92</text>
      <image class="post-like-image" src="/images/icon/view.png" />
      <text class="post-like-font">102</text>
    </view>
  </view>
</view>
```

#### 页面样式

```css
/* pages/posts/posts.wxss */

/* 设置轮播图的大小 */
swiper {
  width: 100%;
  height: 460rpx;
}

swiper image {
  width: 100%;
  height: 100%;
}

/* 文章样式 */
.post-container {
  /* 弹性布局 */
  display: flex;
  flex-direction: column;
  margin-top: 20rpx;
  margin-bottom: 40rpx;
  background-color: #fff;
  /* 上下边框线 */
  border-top: 1rpx solid #ededed;
  border-bottom: 1rpx solid #ededed;
  padding-bottom: 10rpx;
}

/* 作者 日期样式 */
.post-author-date {
  margin: 10rpx 0 20rpx 10rpx;
  display: flex;
  flex-direction: row;
  /* flex 布局居中方案 */
  align-items: center;
}

.post-author {
  width: 60rpx;
  height: 60rpx;
  /* 头像和文字居中 */
  /* vertical-align: middle; */

}

.post-date {
  margin-left: 20rpx;
  font-size:26rpx;
  /* vertical-align: middle; */
}

/* 文章标题 */
.post-title{
  font-size:34rpx;
  font-weight: 700;
  margin-bottom: 20rpx;
  margin-left: 20rpx;
  color:#333;
}
/* 文章主图 */
.post-image{
  width: 100%;
  height: 340rpx;
  margin-bottom: 30rpx;
}
/* 文章内容 */
.post-content{
  color:#666;
  font-size: 28rpx;
  margin-bottom: 20rpx;
  margin-left: 20rpx;
  line-height: 40rpx;
  letter-spacing: 2rpx;
  text-indent: 2em;
}
/* 文章模拟阅读量 */
.post-like{
  display: flex;
  flex-direction: row;
  margin-left: 26rpx;
  align-items: center;
}
.post-like-image{
  height: 32rpx;
  width: 32rpx;
  margin-right: 16rpx;
}
.post-like-font{
  margin-right: 40rpx;
  font-size: 26rpx;
}

```



# 微信小程序入门(三)

**前面我们制作了文章板块。**

我们当时制作的模拟用户收藏文章和浏览次数，使用的是png格式的图片。但是图片有一个非常不好的地方，就是放大会失贞，使用我们打算将其换为字体图标。

### 字体图标的使用

在原生的微信小程序组件中，使用字体图标还是比较麻烦的。所以我们这里使用 `lin-ui`组件库的字体图标组件。

- 在pages.json文件里面注册组件以后就可以直接使用

  ```html
  <l-icon name="research"/>
  ```

- 还可以修改图标的颜色，大小等

  ```html
  <l-icon color="#ccc" size="128" name="research"/>
  ```

**所以这里我们就把上次的png做的图标替换为字体图标了。更加好看也方便。**

```html
<view class="post-like">
      <l-icon color="#666" size="28" name="favor" class="post-like-image" />
      <!-- <image class="post-like-image" src="/images/icon/chat.png"></image> -->
      <text class="post-like-font">92</text>
      <!-- <image class="post-like-image" src="/images/icon/view.png" /> -->
      <l-icon color="#666" size="32" name="eye" class="post-like-image" />
      <text class="post-like-font">102</text>
    </view>
```

![image-20210826195011599](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826195011599.png)

### 生成多篇文章

前面，我们完成了一篇文章的制作，这里我们多复制几次，假设有五篇文章，换一下内容和图片，日期头像等。（我们这里只是为了学习小程序的语法，暂时使用的都是假数据，死数据。实际上数据肯定不是这样写死在页面上的。）

![image-20210826200151890](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826200151890.png)

### 数据来源

实际上我们页面展示的数据，都是从服务器请求过来的。那么就涉及到数据的单向数据绑定和双向数据绑定了。

![image-20210826200629606](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826200629606.png)

#### 单向数据绑定

单向数据绑定，就是通过js发起请求从服务器端获取的数据，我们通过某些手段将数据展示在view（页面，视图）上，让用户看见，而不允许修改。这也是开发中最常见的。



#### 双向数据绑定

说白了，就是js向服务器请求的数据，在页面上展示的同时，用户也可以进行某些更改，然后同步修改了js里请求到的原生数据，二者可以相互影响。现在的小程序已经有（**简易的**）双向数据绑定的机制了。

小程序的双向数据绑定和前端三大框架比起来，应该算是很简单的了。当然在vue/react等框架中，如果对响应式原理不是很了解的话，出现了bug有时候也会很难受的。



#### 实现数据单向绑定

**小程序的生命周期放在后面再说。暂时先简单了解**

##### onLoad生命周期

```js
  /**
   * 生命周期函数--监听页面加载
   * 也可以叫做 钩子函数 hook function
   */
  onLoad: function (options) {
    // onLoad函数，在小程序页面加载的时候，会自动进行回调这个函数。
    console.log(1);
  }
```

**可以发现页面加载的时候，输出了1.**

##### 数据绑定方式一

那么我们如何实现数据绑定呢？

在js文件中，还有一个data属性，data属性是一个对象，在这个里面定义的变量，函数等，在view上是可以直接使用的。这里我们假设第一篇文章的标签是从服务器获取到的。

```js
/**
   * 页面的初始数据
   */
  data: {
    titles:["1-我是服务器请求到的标题！"]
  },
```

**在页面上进行使用该数据。语法就是前面说过的双花括号语法**

```html
<text class="post-title" user-select="true">2021 {{titles[0]}}</text>
```

![image-20210826202643202](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826202643202.png)

##### 数据绑定方式二setData

我们也可以通过setData函数，隐式的定义数据

```js
onLoad: function (options) {
    // onLoad函数，在小程序页面加载的时候，会自动进行回调这个函数。
    // console.log(1);
    // 使用setData函数定义的数据，会隐式的放到data属性上，
    // 也就是说 最终数据都会在data属性上
    this.setData({
      dates:['2021 08 26']
    })
    console.log(this.data);
  }
```

**根据输出，可以看出最终数据是全都在data上定义了**

![image-20210826203941487](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826203941487.png)



#### 数据定义

实现数据绑定的方式有显示和隐式两种，那么我们实际开发需要将数据都显示的定义吗？

答案是 有必要的都显示定义。如果这个变量，数据会被view页面直接引用，那么就建议，显示的定义在data里面。

data里面定义的变量是有初始值的。更多的情况下，我们可以把setData的作用理解为更新数据，而不是纯粹的为了定义数据。都在data里面显示的定义，也更加方便我们的阅读。

#### 小程序的生命周期

生命周期就是页面的加载到卸载（消亡）。小程序的生命周期函数其实就是这个页面从加载到卸载的过程中，进行到某个阶段自动进行回调的函数。

```js
onLoad: function (options) {
    console.log("onLoad");
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    console.log("onReady");
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    console.log("onShow");
  },
```

![image-20210826210356292](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826210356292.png)

可以发现实际的加载顺序是： **onLoad -> onShow -> onReady**

onShow是在onReady前面的，因为页面显示不代表数据渲染也完成了。

其中onLoad生命周期函数是最重要的，也是用的最多的。

而 **onHide和onUnload**两个生命周期函数，是条件触发，并不是说页面必须隐藏，必须卸载。

```js
  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {
    console.log("onHide");
  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {
    console.log("onUnload");
  },
```

页面的卸载我们暂时不好模拟。但是可以模拟隐藏。

点击这个小圆点

![image-20210826211351236](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826211351236.png)

就可以触发隐藏页面

![image-20210826211415177](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826211415177.png)

再次切回小程序，又会触发onShow事件。



#### 简单的数据绑定练习

##### 模拟请求的数据

```js
onLoad: function (options) {

    /**
     * 模拟从服务器请求到了数据
     */
    const content = {
      date: "Sep 18 2021",
      title: "正是虾肥蟹壮时",
      imgSrc: "/images/post/sls.jpg",
      avatar: "/images/avatar/2.png",
      content: "菊黄蟹正肥，品尝秋之味。徐志摩把,“看初花的荻芦”和“到楼外楼吃蟹”,并列为秋天来杭州不能错过的风雅之事；用林妹妹的话讲是“螯封嫩玉双双满，...",
      reading: "112",
      collection: "96",
      author: "林白衣"
      }
    this.setData(content);
  },
```

##### 数据绑定到view

```html
<view class="post-container">
    <!-- 第一部分 作者 日期 -->
    <view class="post-author-date">
      <!-- 头像 -->
      <image class="post-author" src="{{avatar}}"></image>
      <text class="post-date">{{date}}</text>
    </view>
    <!-- 第二部分 文章标题 -->
    <text class="post-title" user-select="true">{{title}}</text>
    <!-- 第三部分 -->
    <image class="post-image" src="{{imgSrc}}"></image>
    <!-- 第四部分 文章内容 -->
    <!-- user-select 方便用户复制 -->
    <text class="post-content" >{{content}}</text>
    <!-- 第五部分 -->
    <view class="post-like">
      <l-icon color="#666" size="28" name="favor" class="post-like-image" />
      <text class="post-like-font">{{collection}}</text>
      <l-icon color="#666" size="32" name="eye" class="post-like-image" />
      <text class="post-like-font">{{reading}}</text>
    </view>
  </view>
```

![image-20210826212734101](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826212734101.png)

![image-20210826212748246](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826212748246.png)

### 条件渲染

有些元素我们需要在某些条件先才进行显示或者不显示，这时候就用到了条件渲染。

进行条件显示的语法：

```html
<标签名 wx:if="条件"/>

<!--单个if条件判断-->
<text wx:if="true"></text>

<!--if-else条件判断-->
<text wx:if="{{flag}}"></text>
<text wx:else></text>

<!--if-else-if条件判断-->
<text wx:if="{{score>90}}">1</text>
<text wx:elif="{{score>80}}">2</text>
<text wx:else>3</text>
```

![image-20210826215207794](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826215207794.png)

[条件渲染的使用](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html)

### 列表渲染

这里模拟一个数组，作为文章的数据。

```js
onLoad: function (options) {

    /**
     * 模拟从服务器请求到了数据
     */
    const content = [{
      date: "Sep 18 2021",
      title: "正是虾肥蟹壮时",
      imgSrc: "/images/post/sls.jpg",
      avatar: "/images/avatar/2.png",
      content: "菊黄蟹正肥，品尝秋之味。徐志摩把,“看初花的荻芦”和“到楼外楼吃蟹”,并列为秋天来杭州不能错过的风雅之事；用林妹妹的话讲是“螯封嫩玉双双满，...",
        reading: "112",
        collection: "96",
      author: "林白衣"
    },
    {
      title: "从视觉到触觉 这款VR手套能给你真实触感",
      content: "8月29日消息，据国外媒体VentureBeat报道，一家名为Dexta Robotics的公司最近发布了一款有望变革虚拟现实手部追踪与交互方式的新产品",
      imgSrc: "/images/post/vr.png",
      reading: 102,
      collection: 26,
      author: "深白色",
      date: "Nov 20 2016",
      avatar: "/images/avatar/4.png",
    }]
    this.setData({
      posts: content
    });
  },
```

**关于列表循环的更多语法在官网都有说明**

[列表循环](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html)

我们这里只是简单的演示，列表循环可以循环数组，也可以循环对象。这里只演示数组循环。

```html
<!-- 使用列表渲染来完成文章的制作 -->
  <!-- 列表渲染的语法： wx:for -->
  <!-- block  一般我们进行列表渲染的时候，都会在block标签上-->
  <!-- block 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 -->
  <!-- block 标签没什么特别的含义，就是相当于一个括号，将多个需要循环的标签包裹起来 -->
  <!-- 循环取posts数组里面的每一项元素遍历 -->
  <!-- 如果没有指定每一项循环元素的名称，那么默认就是 item -->
  <!-- 如果需要修改循环元素的名称，那么我们可以通过 wx:for-item 属性指定，还可以指定数组当前下标的变量名：wx:for-index="index"  -->
  <!-- 默认数组的当前项的下标变量名默认为 index -->
  <block wx:for="{{posts}}" wx:for-item="item">
    <!-- 第二篇文章 -->
    <view class="post-container">
      <!-- 第一部分 作者 日期 -->
      <view class="post-author-date">
        <!-- 头像 -->
        <image class="post-author" src="{{item.avatar}}"></image>
        <text class="post-date">{{item.date}}</text>
      </view>
      <!-- 第二部分 文章标题 -->
      <text class="post-title" user-select="true">{{item.title}}</text>
      <!-- 第三部分 -->
      <image class="post-image" src="{{item.imgSrc}}"></image>
      <!-- 第四部分 文章内容 -->
      <!-- user-select 方便用户复制 -->
      <text class="post-content">{{item.content}}</text>
      <!-- 第五部分 -->
      <view class="post-like">
        <l-icon color="#666" size="28" name="favor" class="post-like-image" />
        <text class="post-like-font">{{item.collection}}</text>
        <l-icon color="#666" size="32" name="eye" class="post-like-image" />
        <text class="post-like-font">{{item.reading}}</text>
      </view>
    </view>
  </block>
```

关于block标签也不需要想太多。进行列表循环的时候，不管那么多直接使用就可以了。

![image-20210826221828245](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826221828245.png)

**列表循环最重要的作用就是用来展示一组数据。**



### 页面的跳转

我们两个页面都基本开发完毕了。接下来回到welcome页面，完成点击按钮实现跳转到pages页面的功能。

#### 什么是事件

都是学过js的兄弟，也就不多赘述了。

- 事件是视图层到逻辑层的通讯方式。
- 事件可以将用户的行为反馈到逻辑层进行处理。
- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。
- 事件对象可以携带额外信息，如 id, dataset, touches。

[你想知道的事件都在这，dddd](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)



#### 捕捉事件

事件发生了，不进行捕获是没有任何意义的。当我们捕捉到事件以后，可以进行一系列我们需要的操作。

我们这里就要实现点击按钮了触发页面跳转的功能。

在移动端，也就是触摸设备上，点击按钮这种操作实际上就是**tap（指触摸后马上离开，实际上就是点击后马上离开）事件**，所以我们需要捕获的就是tap事件。

**捕获事件的语法：**

```html
<!-- 捕获事件： bind:事件名称="函数名称" -->
<view class="btn-journey-container" bind:tap="onTap">
  <!-- 设置样式模拟出我们喜欢的按钮样式 -->
  <text class="journey">开启小程序之旅</text>
</view>
```

**事件回调函数的定义和onLoad等生命周期函数同级。**

```js
// 定义捕获Tap事件后的回调函数
  onTap(params){
    // 捕获事件 并跳转页面
    // 1. 捕获事件 在页面上通过bind进行捕获
    
    // 2. 完成页面的跳转
    console.log('页面跳转！');
  }
```

**当我们单击了按钮以后，就会触发tap事件，进而执行相应的回调函数。**

![image-20210826223805413](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210826223805413.png)

**实际的页面跳转我们在下面说。**

#### 事件捕获语法糖

实际上，我们事件捕获不一定非要写成 **bind:事件**，也可以省略中间的 **:**,但是，我们建议还是不要省略。

```html
<text bindtap="onTap"></text>
```

**不过还是看个人习惯了。后面我们还会看见捕获事件还可以使用catch**



### 路由系统

如果我们想要进行页面的跳转，那么必然离不开小程序的路由系统。

#### navigateTo方法

使用 wx.navigateTo({url: 'url'}) 方法完成页面直接的跳转

- 该方法接收的参数是一个对象，url属性是跳转的路径

- **navigateTo方法的特点：**
  - 该方法跳转的页面，实际上是当前页面的子页面，我们可以从子页面返回当前页面。当然，有子页面，肯定还可以有子子页面，但是页面不能无限的多下去，页面栈最多只能开辟10个，所以最多可以有十个子页面。

```js
wx.navigateTo({
      // 进行页面跳转的时候，填写的页面文件相对整个项目的绝对路径
      url: '/pages/posts/posts',
      // 也可以使用相对路径(可以看我们在app.json中配置的页面路径)
      // url: '../posts/posts',
    })
```

![image-20210827102022824](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827102022824.png)



#### redirectTo方法

我们这里不希望从欢迎页面跳转到pages页面，还可以返回。也就是说欢迎页面我们只想作为一个过渡的页面，不让其和其他页面有什么必然的联系。

那么这里就可以使用redirectTo方法。使用方式和上面的一样。

```js
wx.redirectTo({
      // 进行页面跳转的时候，填写的页面文件相对整个项目的绝对路径
      url: '/pages/posts/posts',
      // 也可以使用相对路径(可以看我们在app.json中配置的页面路径)
      // url: '../posts/posts',
    })
```

![image-20210827102417091](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827102417091.png)

页面跳转后，并没有可以返回父页面的小箭头了。但是这里有一个小房子一样的按钮。

点击这个小房子的按钮也会回到上个欢迎页面。是不是怀疑这个也能回到上个页面呢？

实际上，这个功能是现在新的小程序加进来的功能。这个小房子的按钮是**回到首页用的**，你的首页设置的是什么，就会回到那个页面。并不是所谓的一定回到上个页面。

#### redirectTo和navigateTo方法的区别

**navigateTo方法**会保留当前页面，也就是即使跳转到新的页面，当前页面也保留在页面栈中。

而 **redirectTo**方法会直接销毁当前页面，然后跳转到新的页面。



##### 验证

这里我们可以通过前面提到的小程序的生命周期来进行验证。

我们在welcome页面的监听页面卸载的生命周期函数中写上输出语句进行验证。

```js
 wx.redirectTo({
      // 进行页面跳转的时候，填写的页面文件相对整个项目的绝对路径
      url: '/pages/posts/posts',
      // 也可以使用相对路径(可以看我们在app.json中配置的页面路径)
      // url: '../posts/posts',
    })
/**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {
    console.log("welcome 页面被卸载！");
  },
```

如果是redirectTo方法，我们可以发现，会调用onUnload方法。

![image-20210827103300060](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827103300060.png)

而navigateTo方法则不会触发这个函数。说明页面被保留下来的。只是页面被隐藏了。



### catch和bind事件的区别

bind捕获的就是实实在在在自己身上发生的事件，而catch可以捕获子元素发生的事件，其实就是事件的冒泡。

使用bind来捕获事件，这个事件是可以向上冒泡的。但是一旦使用了catch来进行事件的捕获，这个事件捕获到以后就终止了，不会继续向外传递。

**这里使用三层的事件绑定进行测试**

先使用 catch-bind-bind

![image-20210827105756105](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105756105.png)

1. 当我们点击按钮上的文字时

   ​	![image-20210827105316835](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105316835.png)

2. 点击按钮（不点文字）

   ![image-20210827105351066](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105351066.png)

**测试二：catch-catch-bind**

1. 点击按钮上的文字

   ​	![image-20210827105538207](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105538207.png)

2. 点击按钮 不点文字

   ![image-20210827105610098](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105610098.png)

**测试三：catch-catch-catch**

1. 点击按钮上的文字

   ![image-20210827105823566](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105823566.png)

2. 点击按钮 不点击文字

   ![image-20210827105851616](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827105851616.png)

**综上：使用catch和bind都可以捕获事件，但是catch会阻止冒泡，导致父元素无法进行事件的捕获。**

### js模块的导入导出

现在我们把模拟的文章请求数据从posts.js文件中抽离出去。这里简单模拟几篇数据，需要更多的数据可以自己随意书写。

在ES6中，一个js文件我们就可以视作为一个模块。

**导入导出的语法就不多说了。这玩意都是js基础。**

![image-20210827111737448](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827111737448.png)

![](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827111819681.png)



### 文章跳转

#### 从列表文章跳转到文章详情页

很明显，我们实际上也不可能知道具体有多多少文章，所以实际上的文章详情页也只会有一个。具体显示什么内容肯定是根据实际的文字内容自动填充的。而我们要做的就是做好文章详情内容模板。

**很明显，这里肯定还是需要用到事件。我们需要监听用户的点击事件。**

这个事件应该作用域这篇文章的所有部分，只有点击到了文章上，就进行跳转。实际上这里的跳转不应该这么简单，比如我们点击头像了，可以进行头像图片的放大，或者说跳转到用户详情页，等等。

这里就不考虑那么多了。

![image-20210827115046363](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827115046363.png)

![image-20210827115056149](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827115056149.png)

**随意单击文章的任何地方都能够进行跳转**

因为这里我们去往的是文章详情页，所以应该使用navigateTo方法。

![image-20210827115153119](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827115153119.png)

### 关于列表渲染警告

前面我们发现，使用了列表渲染，一直提示警告。

<img src="https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827115330917.png" alt="image-20210827115330917"  />

这里建议我们使用 wx:key属性，可以提高列表渲染的性能。

![image-20210827115808352](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210827115808352.png)

我这里的postId是在模拟的数据中添加的属性。key绑定的值只要是唯一的就可以了。当然我们也不建议绑定文章数据在数组中的索引。那样其实也并不是合法的。

然后就是新的小程序这里绑定是不需要使用双花括号语法的，也不需要item.postId来绑定。因为这是在循环的那层标签上。

以前是可以使用双花括号语法进行绑定的，现在新版的小程序进行了修改。





# 微信小程序入门(四)-完成文章详情页



### 制作静态页面

**先有死数据制作出我们想要的效果**

![image-20210828102541148](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828102541148.png)

**布局也比较简单，直接上代码**

#### 页面结构

```html
<!--pages/post-detail/post-detail.wxml-->

<!-- 先静后动 -->
<view class="container">
  <image class="head-image" src="/images/post/bl.png"></image>

  <!-- 头像区域 -->
  <view class="author-date">
    <image class="avatar" src="/images/avatar/1.png"></image>
    <text class="author">听雨少年</text>
    <text class="const-text">发表于</text>
    <text class="date">16小时前</text>
  </view>
  <!-- 标题 -->
  <text class="title">你好！！！！
  </text>

  <!-- 图标 -->
  <view class="tool">
    <view class="circle">
      <image src="/images/icon/collection-anti.png"></image>
      <image class="share-image" src="/images/icon/share.png"></image>
    </view>
    <!-- 水平线 -->
    <view class="horizon"></view>
  </view>

  <!-- 文章文本 -->
  <text class="detail">哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</text>
</view>
```

#### 页面样式

```css
/* pages/post-detail/post-detail.wxss */

.container {
  display: flex;
  flex-direction: column;
}

/* 图片 */
.head-image {
  width: 100%;
  height: 460rpx;
}

/* 头像区域 */
.author-date {
  display: flex;
  flex-direction: row;
  margin-top: 20rpx;
  margin-left: 32rpx;
  align-items: center;
}

.avatar {
  width: 64rpx;
  height: 64rpx;
}

.author {
  font-size: 30rpx;
  font-weight: 300;
  margin-left: 20rpx;
  color: #666;
}

.const-text {
  font-size: 24rpx;
  color: #999;
  margin-left: 20rpx;
}

.date {
  font-size: 24rpx;
  color: #999;
  margin-left: 30rpx;
}

/* 标题 */
.title {
  margin-left: 40rpx;
  font-size: 36rpx;
  font-weight: 30rpx;
  margin-top: 30rpx;
  color: #4b556c;
  letter-spacing: 2px;
}

/* 图标 */
.tool {
  display: flex;
  /* 设置主轴 */
  flex-direction: column;
  /* 侧轴排列方式 */
  align-items: center;
  /* 垂直居中 主轴排列方式  */
  justify-content: center;
}

.circle {
  display: flex;
  width: 660rpx;
  justify-content: flex-end;
}

.circle image {
  width: 90rpx;
  height: 90rpx;
}

.circle image:last-child {
  margin-left: 20rpx;
}

.horizon {
  width: 660rpx;
  height: 1px;
  background-color: #e5e5e5;
  position: absolute;
  z-index: -1;
}
/* 文本 */
.detail{
  color:#666;
  margin-left: 30rpx;
  margin-top: 20rpx;
  margin-right: 30rpx;
  line-height: 44rpx;
  letter-spacing: 2px;
  text-indent: 2em;
}
```



### 页面跳转

#### 传递文章数据

我们页面的布局制作好了。接下来就是点击哪一篇文章，就显示哪一篇文章的详情页。这时候跳转的时候我们就需要传递数据。

我们采用自定义属性来保存当前文章的文章号。

#### 自定义属性

![image-20210828105003033](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828105003033.png)

#### 事件对象获取自定义属性

```js
// event  事件
  onGoToDetail(event) {
    // 使用事件对象 拿到我们当前文章的文字号 
    // 通过 currentTarget.dataset 可以拿到我们事件目标上自定义的 data-属性
    // 我们可以通过这个对象拿到定义在事件对象上的属性 data- 后面的就是自定义的属性
    // 小程序自定义的 data- 属性的规则
    // data-id ---> id
    // data-Id ---> id
    // data-postId ---> postid
    // data-PostId ---> postid
    // data-post-id ---> postId
    // data-post-ID ---> postId
    console.log(event.currentTarget.dataset);
    wx.navigateTo({
      // 跳转文章详情页
      url: "/pages/post-detail/post-detail",
    })
  },
```

#### 页面通信

页面跳转的时候，我们将文章号传递过去。一般都是通过url来传递参数。

url?参数1=值1

?后面的参数我们也叫查询参数，查询字符串。

**所以页面跳转的时候，我们将文章号传递过去**

```js
wx.navigateTo({
      // 跳转文章详情页
      url: "/pages/post-detail/post-detail?pid="+event.currentTarget.dataset.postId,
    })
```

##### 参数的接收

传递到本页面的参数，我们可以通过生命周期函数中的onLoad函数里面的参数options来获取到查询字符串里面的值。

```js
/**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 通过监听页面加载的的函数的参数options，机也可以拿到我们传递过来本页面的参数
    console.log(options);
  },
```

![image-20210828105721859](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828105721859.png)

#### 渲染指定文章详情页

我们拿到前面传递过来的文章号，就可以再次模拟请求数据，然后进行数据的渲染。

```js
// pages/post-detail/post-detail.js

// 导入数据
import postList from '../../data/data.js'
Page({

  /**
   * 页面的初始数据
   */
  data: {
    post: {}
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 通过监听页面加载的的函数的参数options，机也可以拿到我们传递过来本页面的参数
    // 注意：查询字符串（参数）的类型都是字符串类型
    // console.log(options);
    const [post] = [...postList.filter(post => post.postId === parseInt(options.pid))];

    // console.log(post);
    // 拿到我们指定的文章
    this.setData(post);
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {

  }
})
```

#### 页面数据替换

```html
<!--pages/post-detail/post-detail.wxml-->

<!-- 先静后动 -->
<view class="container">
  <image class="head-image" src="{{imgSrc}}"></image>

  <!-- 头像区域 -->
  <view class="author-date">
    <image class="avatar" src="{{avatar}}"></image>
    <text class="author">{{author}}</text>
    <text class="const-text">发表于</text>
    <text class="date">{{dateTime}}</text>
  </view>
  <!-- 标题 -->
  <text class="title">{{title}}
  </text>

  <!-- 图标 -->
  <view class="tool">
    <view class="circle">
      <image src="/images/icon/collection-anti.png"></image>
      <image class="share-image" src="/images/icon/share.png"></image>
    </view>
    <!-- 水平线 -->
    <view class="horizon"></view>
  </view>

  <!-- 文章文本 -->
  <text class="detail">{{detail}}</text>
</view>
```

#### 效果

![image-20210828111416810](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828111416810.png)

### 缓存机制/异步API

#### app.js的作用

接下来，我们想完成在文章详情页的收藏和取消收藏。并记录下是否收藏的状态。实际上用户收藏以后，应该是向服务器发起请求，将数据保存在服务器端。但是这里我们没有使用数据库，那么就需要考虑保存在本地的某个地方。比如：全局变量。当然这不是最好的。

而小程序的全局变量，是写在app.js中的。

##### 小程序的生命周期

小程序的生命周期和页面的生命周期类似。

```js
App({
  /**
   * 小程序启动的生命周期
   */
  onLaunch() {
    console.log('小程序启动！');
  },
  /**
   * 小程序页面展示的时候
   */
  onShow() {
    console.log('onShow!');
  },
  /**
   * 小程序隐藏的时候执行
   */
  onHide() {
    console.log('小程序隐藏！');
  },
  /**
   * 小程序出现错误的时候执行
   */
  onError() {
    console.log('小程序报错！');
  }
})
```

##### 定义全局变量

在app.js文件中，可以定义全局变量。和小程序的生命周期函数定义的位置是一样的。

```js
App({
    name:'App.js name'
})
```

##### 在页面获取全局变量

定义的全局变量如何获取呢？

其实，在其他页面，可以通过小程序通过的getApp()函数，来获取定义的全局变量的对象。

```js
const app = getApp()
console.log(app);
```

![image-20210828163111487](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828163111487.png)

**所以我们在app.js中定义的全局变量，是可以在所有页面进行全局共享的。**

但是，并不是说全局的变量的数据就是一直不变的。当小程序重启了，数据又会回到最开始的状态。所以 **不能把全局变量当做一个永久数据保存的地方。**



#### 小程序的缓存

很明显，用全局变量来记录用户是否收藏一篇文章并不是一个很好的方案。

那么，我们应该采取什么手段？

这里引入小程序的缓存来解决。

什么是小程序的缓存？其实和我们js中的localstorage很相似。

即使我们的小程序重启了，保存在缓存中的数据依然是有效的，不会被重置。而定义在app.js中的全局变量则在小程序重启后会被重置。

##### 同步缓存

通过小程序通过的setStorageSync()的方法，可以同步设置或者更新缓存。

```js
Page({
    /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 同步设置（修改）缓存的方法
    // 两个参数：键  值
    wx.setStorageSync('flag', true);
    // 删除缓存
    wx.removeStorageSync("flag");
    // 清空所有缓存
    wx.clearStorageSync();
    wx.setStorageSync('name', "你好！ ")
    // 获取我们设置的缓存
    const n = wx.getStorageSync("name");
    console.log(n); 
  }
})
```

**通过小程序的调试器是可以看见和管理我们的缓存的。即使程序重启缓存也不会消失 的。**

![image-20210828164843681](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828164843681.png)

通过这个按钮就可以清空缓存

![image-20210828164957922](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828164957922.png)

你也可以自己手动在这里新建缓存。

##### 异步缓存

异步设置缓存在设置缓存较多的时候，可以提升用户体验。以前我们设置或者删除缓存是通过回调函数来执行成功后的操作。

```js
// 异步设置缓存 参数是一个对象 key是键 data是数据 也就是设置的value
    wx.setStorage({
      data: '毛毛1',
      key: 'name',
    });
    // 获取缓存 参数也是对象
    wx.getStorage({
      // 要获取的缓存的键名
      key: 'name',
      // 获取成功后的回调函数
      success(res) {
        console.log(res); // post-detail.js? [sm]:50 {errMsg: "getStorage:ok", data: "毛毛1"}
      }
    });

    // 移除缓存
    wx.removeStorage({
      key: 'name',
      // 移除属性成功后的回调函数
      success(res){
        console.log(res);
      }
    })

    // 清空缓存
    wx.clearStorage({
      // 缓存清空成功后的回调
      success: (res) => {
      console.log(res);
      },
    })
```

**如果我们异步获取缓存的时候，不设置回调函数，可以得到一个promise对象的返回值。**

**如果对promise不了解的，可以先去了解一下。**

```js
wx.setStorage({
      data: '听雨少年',
      key: 'name',
    });
    // 获取缓存 无回调
    const res =wx.getStorage({
      key: 'name',
    });
    console.log(res instanceof Promise); // true
    // 传统的promise 获取成功后的结果 ES6新增
    res.then((value)=>{
      console.log(value);// {errMsg: "getStorage:ok", data: "听雨少年"}
    })
```

**但是，这种操作promise对象有了更好的解决方案。可以使用ES7新增的async 和 await关键字。**

```js
async onLoad(){
wx.setStorage({
      data: '听雨少年',
      key: 'name',
    });
    const res = await wx.getStorage({
      key: 'name',
    })
    console.log(res);// {errMsg: "getStorage:ok", data: "听雨少年"}
  }
```

### 实现文章收藏功能

接下来我们要做的，就是完成文章的收藏功能。

![image-20210828173659726](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828173659726.png)

#### 第一步：点击事件

![image-20210828212838805](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828212838805.png)

```html
<!-- 条件渲染：在收藏和未收藏的图标之间切换 -->
      <image wx:if="{{!collected}}" bind:tap="onCollect" src="/images/icon/collection-anti.png"></image>
      <image wx:else bind:tap="onCollect" src="/images/icon/collection.png"></image>
```

这里用一个变量来控制收藏和未收藏的图片切换。

#### 第二步：收藏缓存

如果想要完成小程序刷新后还可以记录好文章是否收藏的状态，我们需要将当前的文章状态保存到缓存中。

如何完成所有文章都可以互不影响的缓存呢？

这里采用的方式是：记录一个对象，将每篇文章的id作为属性，是否收藏了这篇文章作为这个属性的值。

比如：

```js
post_collection = {
    // id:true/false
    1:true,
    6:false
}
```

#### 第三步：实现

##### 定义数据

```js
/**
   * 页面的初始数据
   */
  data: {
    post: {},
    // 记录当前文章的id
    _pid: null,
    // 当前文章是否收藏
    collected: false,
    // 所有文章是否收藏的缓存对象
    _postsCollected:{}
  }
```

##### 页面初始化

```js
/**
   * 生命周期函数--监听页面加载
   */
  async onLoad(options) {
    const [post] = [...postList.filter(post => post.postId === parseInt(options.pid))];

    // 记录文章id
    this.data._pid = post.postId;

    // console.log(post);
    // 拿到我们指定的文章
    this.setData(post);

    // 读取缓存，拿到文章是否收藏的状态
    const { data: postsCollected } = await wx.getStorage({
      key: 'post_collected'
    })
    // 记录所有文章的缓存状态的对象
    this.data._postsCollected = postsCollected;
    // 拿到当前文章的收藏状态 取不到则表示这篇文章未收藏
    const collected = postsCollected[this.data._pid] || false;
    console.log(postsCollected);
    console.log(collected);
    this.setData({ collected });
  }
```

##### 图片收藏切换函数

```js
/**
   * 文章收藏点击事件的回调
   * @param {*} event  事件对象
   */
  async onCollect(event) {
    // 假设文章未收藏
    // 点击后 未收藏 -> 收藏
    // 将是否收藏的状态保存到缓存中
    // 记录那篇文章是否被收藏，还可以同时进行记录多篇文章
    // const { data: postCollected = {} } = await wx.getStorage({
    //   key: 'post_collected',
    // })
    const postCollected = this.data._postsCollected;
    console.log(postCollected);
    // 当前文章的收藏状态 取不到则肯定没有收藏过
    const collected = postCollected[this.data._pid] || false;
    // 用文章id的值作为实际存储对象的属性，属性值是是否收藏
    postCollected[this.data._pid] = !collected;
    wx.setStorageSync('post_collected', postCollected)
    this.setData({
      // 这里直接取反就可以了 上面的执行完毕这里可以直接取反了
      collected: !this.data.collected
    });
  }
```

##### 功能实现

通过上面的方式，我们其实就已经实现了将收藏状态进行了本地存储，即使退出去，重新加载也会记录下以前的状态。

![image-20210828214652277](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828214652277.png)

![image-20210828214704873](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828214704873.png)

**但是，这里还是有一个bug。**

##### 缓存的bug

这里这样做实际上是有一些bug的。

因为如果是用户第一次访问，那么也就没有缓存。那么我们在加载的时候，是取不到缓存中的值的。那么系统肯定是会在控制台报错的，这个问题还是有点头疼。我也没想到让我满意的解决方法。虽然这个问题不影响我们使用。**回头在想想。**

![image-20210828215450477](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828215450477.png)

#### 优化用户收藏体验

##### 再次完善页面

这里将字体修改一下，在全局的样式中进行更改。看起来舒服点。

```css
/* app.wxss */
text{
  color:#666;
  font-size: 24rpx;
  font-family: 'MicroSoft Yahei';
}
```

![image-20210828215900962](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828215900962.png)

##### 弹框提示是否收藏成功

我们可以使用小程序原生提供的某些API，组件。在用户点击收藏或者取消收藏的时候提示用户收藏成功还是取消收藏了。

只需要在点击事件的执行函数中，调用小程序提供好的弹框组件即可。

```js
// 使用小程序默认的API 弹框组件来提示用户是收藏文章 还是取消收藏
    wx.showToast({
      // 提示文字
      title: this.data.collected ? "收藏文章成功！" : "取消收藏成功！",
      // 提示框停留时间
      duration: 2000,
        // 图标属性 icon: "success"/"error"
    })
```

![image-20210828220949620](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828220949620.png)



[没错，我就是你想要的提示框](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)



#### 使用模态对话框

上面我们使用弹框来提示用户是否收藏成功，其实这种轻提示也是非常好的。这里我的想法是使用模态对话框来进行一次练习。实际上这种方式没有上面的那种方式好，这里仅仅作为一波小练习而已。

##### 模态对话框的基本使用

```js
// 模态对话框 showModel
    wx.showModal({
      title:"是否收藏文章",
      success(res){
        // 不管取消还是确定，都会执行这个回调函数，因为这个函数的执行时机就是 接口调用成功的回调函数 也就是出现了这个模态框，就一定会被执行的函数
        if(res.confirm){
          // res.confirm 为 true 时，表示用户点击了确定按钮
        }else if(res.cancel){
          // res.cancel  为 true 时，表示用户点击了取消
        }
      }
    })
```

##### 模态对话框的改进

如果我们使用上面的这种方式，那么就需要将其他的代码全都放到success这个回调函数中执行。很明显这不是我们想要的。这种写法会导致代码看起来很臃肿。那么我们可以如何做呢？

```js
const res = wx.showModal({
      title:"是否收藏文章",
    })
    console.log(res); // Promise对象
```

如果我们调用模态框的时候，不传递回调函数success，就可以得到这个函数的返回值，是一个Promise的对象。

很明显，可以使用**async 和 await**关键字了来完成异步调用了。

```js
/**
   * 文章收藏点击事件的回调
   * @param {*} event  事件对象
   */
  async onCollect(event) {
    const res = await wx.showModal({
      title: this.data.collected?"取消收藏？":"收藏文章？",
    })
    // console.log(res);
    if (res.confirm) { // 收藏文章
      const postCollected = this.data._postsCollected;
      // console.log(postCollected);

      // 当前文章的收藏状态 取不到则肯定没有收藏过
      const collected = postCollected[this.data._pid] || false;
      // 用文章id的值作为实际存储对象的属性，属性值是是否收藏
      postCollected[this.data._pid] = !collected;
      wx.setStorageSync('post_collected', postCollected)
      this.setData({
        // 这里直接取反就可以了 上面的执行完毕这里可以直接取反了
        collected: !collected
      });
    }
  },
```

![image-20210828225352701](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828225352701.png)

![image-20210828225404289](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828225404289.png)

**实际上想要达到的效果都是一样的。但是为了用户体验，我们还是采取最开始的弹框方式。**

### 文章分享

#### 注册事件

```html
<!-- 点击触发文章分享事件 -->
      <image bind:tap="onShare" class="share-image" src="/images/icon/share.png"></image>
```

![image-20210828225930257](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828225930257.png)

#### 功能的完成

完成文章的分享，我们实际上还是调用微信小程序提供好的内置组件。具体的更多的使用方式可以参考官方文档。

```js
/**
   * 完成文章分享的回调函数
   * @param {*} event 
   */
  onShare(event) {
    // 调用小程序原生的组件 实现分享
    wx.showActionSheet({
      // 分享的方式(具体分享以后做什么，我们并没有做)
      itemList: ["分享到QQ", "分享到微信", "分享到微博", "分享到朋友圈"],
      success(res){
        // 通过 res.tapIndex 可以拿到我们点击了哪一个数组元素的索引
        // 想做其他事情可以做
        console.log(res.tapIndex);
      }
    })
  }
```

![image-20210828230806200](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828230806200.png)

#### 内置的分享

实际上，我们想要分享微信小程序，也不需要自己写功能。小程序已经内置了分享功能。**点击这三个点的按钮就可以看见。**

![image-20210828230931461](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210828230931461.png)

[更多分享用法请参考](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showActionSheet.html)





# 微信小程序入门(五)



### 音乐播放功能

#### 制作样式

静态样式没啥好说的，基本上有手就行了。

```html
<view class="head-image-audio">
    <image class="head-image" src="{{imgSrc}}"></image>
    <!-- 实现音乐播放  -->
    <image class="audio" src="/images/music/music-start.png" />
  </view>
```

```css
/* 大图+音乐播放 */
.head-image-audio {
  position: relative;
  height: 460rpx;
}

/* 图片 */
.head-image {
  width: 100%;
  height: 100%;
}

/* 音乐播放 */
.audio {
  width: 102rpx;
  height: 110rpx;
  position: absolute;
  /* 居中 */
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  opacity: .6;
}
```

![image-20210829110147532](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829110147532.png)

我们想要实现的功能就是点击以后实现音乐的播放。

#### 背景音频播放

这里也需要了解一下官方提供的关于背景音频播放的API组件。

##### 绑定事件

老规矩，肯定还是需要在图片上绑定点击事件。

```html
<!-- 实现音乐播放  -->
    <image bind:tap="onMusic" class="audio" src="/images/music/music-start.png" />
```

##### 功能测试

这里先简单的使用一下背景音频。

```js
/**
   * 音乐播放功能
   * @param {*} event 
   */
  onMusic(event) {
    // 获取全局唯一的背景音频管理器。 小程序切入后台，如果音频处于播放状态，可以继续播放。但是后台状态不能通过调用API操纵音频的播放状态
    const mgr = wx.getBackgroundAudioManager();
    // 赋值音乐播放的链接
    mgr.src = this.data.music.url;
    // 音乐播放的标题
    mgr.title = this.data.music.title;
   }
```

![image-20210829112622826](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829112622826.png)

咳咳，很明显，没什么大毛病。用起来也不难。

##### 控制台报错

![image-20210829112702351](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829112702351.png)

虽然使用没什么问题，但是控制台给我们了报错提示。这时候，我们去这个地址看看。

为了能够转后台以后可以继续播放音频。我们就在app.json文件中配置一下。

![image-20210829112917612](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829112917612.png)



**当我们在app.json中配置了这个属性，并且数组里面只有一个值audio时**

```json
"requiredBackgroundModes": ["audio"]
```

**音乐播放的同时，切后台音乐也会一直播放。**

<span style="color:red">而只使用location这个值，只有在小程序没有退出的时候才会一直播放，一旦切后台，音乐就会停止。 </span>

```json
"requiredBackgroundModes": ["location"]
```

**我们这里就把两个值都加上吧。**

```json
"requiredBackgroundModes": ["audio","location"]
```



#### 切换音乐播放图标

因为需要进行音乐播放与停止的切换，所以图标也需要更改。

```html
<!-- 实现音乐播放  -->
    <!-- 播放和暂停图标的切换 条件渲染 -->
    <!-- 当然这里用三元表达式就不需要使用两个标签了 -->
    <image wx:if="{{!isPlaying}}" bind:tap="onMusicStart" class="audio" src="/images/music/music-start.png" />
    <image wx:else bind:tap="onMusicStop" class="audio" src="/images/music/music-stop.png" />
```

```js
/**
   * 音乐播放开始功能
   * @param {*} event 
   */
  onMusicStart(event) {
    // 获取全局唯一的背景音频管理器。 小程序切入后台，如果音频处于播放状态，可以继续播放。但是后台状态不能通过调用API操纵音频的播放状态
    const mgr = wx.getBackgroundAudioManager();
    // 赋值音乐播放的链接
    mgr.src = this.data.music.url;
    // 音乐播放的标题
    mgr.title = this.data.music.title;
    // 播放时使用的图片
    mgr.coverImgUrl = this.data.music.coverImg;
    // 切换当前音乐的播放状态为 播放中
    this.setData({
      isPlaying: true
    });

  },
  /**
   * 音乐暂停的事件处理
   * @param {*} event 
   */
  onMusicStop(event) {
    const mgr = wx.getBackgroundAudioManager();
    // 音乐停止
    mgr.stop();
    // 音乐状态的切换
    this.setData({
      isPlaying:false
    })
   },
```

**说实话，这样的确达到了音乐的停止和播放之间状态的切换。但是，你会发现每次切换播放和暂停音乐以后，音乐需要重新播放、并且，如果在音乐播放的时候，我们点击下面的控制面板，可以发现，音乐暂停了，但是图标不会自动切换。问题还是很多。**

![image-20210829141418289](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829141418289.png)





#### 同步音乐控制开关与图标的状态

##### 背景音频对象的播放/暂停事件回调

很明显，想要达到我们需要的某些状态，肯定是需要使用音频对象提供的某些回调函数。

![image-20210829142040225](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829142040225.png)

所以我们通过这两个事件，来根据音乐的播放和暂停调用不同的函数。

##### 进一步优化

因为我们会在很多地方都使用到这个背景音频的对象，所以我们将其放到data数据源中，并且在页面加载的时候进行获取，同时在onLoad中监听音乐的播放和暂停两个事件。

```js
/**
   * 页面的初始数据
   */
  data: {
    post: {},
    // 记录当前文章的id
    _pid: null,
    // 当前文章是否收藏
    collected: false,
    // 所有文章是否收藏的缓存对象
    _postsCollected: {},
    // 音乐是否播放中
    isPlaying: false,
    // 背景音频对象
    _mgr: null
  },

  /**
   * 生命周期函数--监听页面加载
   */
  async onLoad(options) {
    // 通过监听页面加载的的函数的参数options，机也可以拿到我们传递过来本页面的参数
    // 注意：查询字符串（参数）的类型都是字符串类型
    // console.log(options);
    const [post] = [...postList.filter(post => post.postId === parseInt(options.pid))];

    // 记录文章id
    this.data._pid = post.postId;

    // console.log(post);
    // 拿到我们指定的文章
    this.setData(post);

    // 读取缓存，拿到文章是否收藏的状态
    const { data: postsCollected } = await wx.getStorage({
      key: 'post_collected',
    })
    // 记录所有文章的缓存状态的对象
    this.data._postsCollected = postsCollected;
    // 拿到当前文章的收藏状态 取不到则表示这篇文章未收藏
    const collected = postsCollected[this.data._pid] || false;
    // console.log(postsCollected);
    // console.log(collected);
    this.setData({ collected });

    

    const mgr = wx.getBackgroundAudioManager();
    this.data._mgr = mgr;
    // 监听背景音乐的播放和停止
    // mgr.onPlay(()=>{
    //   // 音乐播放
    //   this.onMusicStart();
    // });
    mgr.onPlay(this.onMusicStart);
    // 音乐暂停的回调处理
    mgr.onPause(this.onMusicStop);
  },
  /**
   * 文章收藏点击事件的回调
   * @param {*} event  事件对象
   */
  async onCollect(event) {

    const postCollected = this.data._postsCollected;


    // 当前文章的收藏状态 取不到则肯定没有收藏过
    const collected = postCollected[this.data._pid] || false;
    // 用文章id的值作为实际存储对象的属性，属性值是是否收藏
    postCollected[this.data._pid] = !collected;
    wx.setStorageSync('post_collected', postCollected)
    this.setData({
      // 这里直接取反就可以了 上面的执行完毕这里可以直接取反了
      collected: !collected
    });

    // 使用小程序默认的API 弹框组件来提示用户是收藏文章 还是取消收藏
    wx.showToast({
      // 提示文字
      title: this.data.collected ? "收藏文章成功！" : "取消收藏成功！",
      // 提示框停留时间
      duration: 2000
    })


  },
  /**
   * 完成文章分享的回调函数
   * @param {*} event 
   */
  onShare(event) {
    // 调用小程序原生的组件 实现分享
    wx.showActionSheet({
      // 分享的方式(具体分享以后做什么，我们并没有做)
      itemList: ["分享到QQ", "分享到微信", "分享到微博", "分享到朋友圈"],
      success(res) {
        // 通过 res.tapIndex 可以拿到我们点击了哪一个数组元素的索引
        // 想做其他事情可以做
        // console.log(res.tapIndex);
      }
    })
  },
  /**
   * 音乐播放开始功能
   * @param {*} event 
   */
  onMusicStart(event) {
    const mgr = this.data._mgr;
    // 赋值音乐播放的链接
    mgr.src = this.data.music.url;
    // 音乐播放的标题
    mgr.title = this.data.music.title;
    // 播放时使用的图片
    mgr.coverImgUrl = this.data.music.coverImg;
    // 切换当前音乐的播放状态为 播放中
    this.setData({
      isPlaying: true
    });
  },
  /**
   * 音乐暂停的事件处理
   * @param {*} event 
   */
  onMusicStop(event) {
    const mgr = this.data._mgr;
    // 音乐停止
    mgr.stop();
    // 暂停播放
    // mgr.pause();
    // 音乐状态的切换
    this.setData({
      isPlaying: false
    })
  },
```

![image-20210829144141275](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829144141275.png)

这样就可以完成音乐的停止和播放之间的切换了。

但是，这样做我们音乐就直接停止了，用户点击的是暂停按钮，按理说我们要做的应该是让音乐暂停，而不是直接终止。

很显然，用户点击控制面板的暂停，应该就是让音乐暂停，而不是直接停止。

**所以说，我们要做的，应该是点击我们自己的按钮，实现的是音乐的播放和停止，而用户点击下面的控制面板，应该是在播放和暂停之间切换。**



##### 再一次优化音乐的暂停和停止

话都说的这么明白了，接下来不用我说，有手就行了。

这里将音乐停止的函数进行改进。

```js
/**
   * 音乐暂停的事件处理
   * @param {*} isStop 停止音乐 
   */
  onMusicStop(isStop = true) {
    // const mgr = wx.getBackgroundAudioManager();
    const mgr = this.data._mgr;
    if (isStop) {
      // 音乐停止
      mgr.stop();
    } else {
      // 暂停播放
      mgr.pause();
    }
    // 音乐状态的切换
    this.setData({
      isPlaying: false
    })
  },
  async onLoad(options) {
      // 省略 。。。
      const mgr = wx.getBackgroundAudioManager();
      this.data._mgr = mgr;
      mgr.onPlay(this.onMusicStart);
      // 音乐暂停的回调处理
      mgr.onPause(this.onMusicStop.bind(this,false));
}
```

这就达到了我们想要的效果。点击下面的控制面板，音乐暂停；点击上面图片按钮，音乐由播放转为停止。

![image-20210829145522243](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829145522243.png)

#### 音乐播放状态的初始化问题

当我们解决了上面的问题之后，接下来其实很有其他问题。

![image-20210829150048411](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829150048411.png)

当我们点击返回按钮，此时音乐还是处于播放状态，因为我们没有停止播放。再次进行本页面的时候，这个音乐还是播放中，但是我们的图标和下面音乐的状态对不上了。

![image-20210829151024017](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829151024017.png)

原因当然很明显，是我们的状态问题，每次我们页面的加载时，状态都被重置为false。 

这里我们可以采用全局变量的方式，来记录音乐的播放与否。没必要使用缓存，因为缓存是持久化的。实际上程序退出了就没必要管音乐的事情了。

##### 在优化

这思路就很简单了。搞一个全局变量，每次在音乐状态切换的同时，我们全局的状态跟着改变。

```js
// app.js

App({
  // 记录音乐的播放状态
  gIsPlayingMusic:false
})
```

```js
// // pages/post-detail/post-detail.js

// 全局的小程序对象，用来获取我们的全局变量
const app = getApp()

Page({
    onLoad(){
        // 获取全局记录的播放状态
    	this.setData({
      	isPlaying: app.gIsPlayingMusic
    	});
    },
    /**
   * 音乐播放开始功能
   * @param {*} event 
   */
  onMusicStart(event) {

    // 改变全局的音乐播放状态
    app.gIsPlayingMusic = true;
  },
  /**
   * 音乐暂停的事件处理
   * @param {*} isStop 停止音乐 
   */
  onMusicStop(isStop = true) {
    // 改变全局的音乐播放状态
    app.gIsPlayingMusic = false;
  }
})
```

**其它代码都不在赘述。**

![image-20210829152951445](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829152951445.png)

#### 分析其它问题

##### 不是问题也是问题的问题

老实说，改了这么多，还是有一些小的bug。刚解决一个又来一个。

这个问题说是问题，也可以说不是问题。

就是我们发现，我们当前文章的歌曲在播放，然后我们退出去进入其他页面，按理说其他页面的歌曲和我们这个是不一样的歌曲，应该是不应该让音乐按钮显示播放状态的，但是我们每次获取的状态都是全局的，所以导致只要有音乐在播放，进去其他文章也都是会显示播放状态。

这个问题你说是问题，其实也没错，本来就是bug。你要是说不是问题，也没毛病，本来就是有音乐就是在播放中。

**这里我理解呢是bug。就简单的解决一下。**

思路还是那么明显，搞个全局变量就完事。弄一个全局变量记录当前音乐播放是属于那篇文章的。这样在赋值播放状态的时候，我们就可以根据文章的id号是否相同，来解决这个问题。

##### 全局变量

```js
// app.js

  // 记录音乐的播放状态
  gIsPlayingMusic: false,
  // 记录播放的音乐是属于那篇文章的 默认是-1
  gIsPlayingPostId: -1
```

##### 文章音乐播放状态

```js
/**
   * 当前文章的音乐播放状态 
   * 
   * @returns 只有音乐所属的文章号是当前所在的文章页面，且音乐一直处于播放状态， 返回true
   */
  currentPostMusicIsPlaying() {
    if (app.gIsPlayingMusic && this.data._pid === app.gIsPlayingPostId)
      return true;
    return false;
  }
```

##### 文章音乐暂停和停止

音乐暂停的逻辑不需要改变，音乐停止的逻辑进行修改

```js
/**
   * 音乐暂停的事件处理
   * @param {*} isStop 停止音乐 
   */
  onMusicStop(isStop = true) {
    const mgr = this.data._mgr;
    if (isStop) {
      // 音乐停止
      mgr.stop();
      // 音乐停止，重置全局音乐的文章id
      app.gIsPlayingPostId = -1;
    } else {
      // 暂停播放
      mgr.pause();
    }
    // 音乐状态的切换
    this.setData({
      isPlaying: false
    })
    // 改变全局的音乐播放状态
    app.gIsPlayingMusic = false;
  }
```

##### onLoad初始化的时候赋值

```js
onLoad(){
       // 音乐播放状态 只有音乐所属的文章号是当前所在的文章页面，且音乐一直处于播放状态，我们才重置音乐的播放状态为true
    this.setData({
      isPlaying: this.currentPostMusicIsPlaying()
    });
}
```

![image-20210829162601019](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210829162601019.png)

#### 还未解决的bug

**解决了很多问题。但是还是存在一些问题。**

##### 音乐播放完毕，图标不同步

当我们音乐播放完毕后，上面的图标并没有同步的进行状态的切换，音乐都播放完了，按理说状态应该是未播放。



##### 音乐播放时进入其他文章

表面上，我们解决了这些问题，但是进去其他页面的时候，如果我们点击了音乐的暂停，这很ok。如果暂停后再次点击播放，播放的音乐就变成当前文章的背景音乐了。我觉得这也不是很合理的。



**bug很多。头疼。**







# 微信小程序入门(六)-自定义组件

### 完善文章轮播图

#### 轮播图文章跳转

前面我们的轮播图只能简单的动起来。

现在打算实现点击轮播图上的图片，跳转到对应的文章详情页去。只要在图片上绑定文章的id号即可。用到的函数还是我们之前用来进行文章详情页跳转的函数。

![image-20210830155819318](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830155819318.png)

![image-20210830155923444](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830155923444.png)



### 生成tabBar选项卡

#### 配置生成

小程序提供的有tabBar的选项卡。我们只需要在app.json中配置这个选项，即可生成。

```json
"tabBar": {
    "list": [
      {
          // tabbar的标题 
        "text": "阅读",
          // 点击这个bar后去往的页面路径（必填）
        "pagePath": "pages/posts/posts"
      },
      {
        "text": "电影",
        "pagePath": "pages/movies/movies"
      }
    ]
  }
```

![image-20210830161307756](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830161307756.png)

![image-20210830161329755](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830161329755.png)





#### tabBar的其他配置

![image-20210830162513452](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830162513452.png)

```json
"tabBar": {
    // 设置边框线的颜色为白色 这样舒服点
    "borderStyle": "white",
    // bar的位置 可以在顶端
    "position": "bottom",
    // bar未选中时文字的颜色
    "color": "#999",
    // 选中当前bar，文字的颜色
    "selectedColor": "#333",
    "list": [
      {
        "text": "阅读",
        "pagePath": "pages/posts/posts",
          // 未选中时的图标
        "iconPath": "/images/tab/yuedu.png",
          // 选中时的图标
        "selectedIconPath": "/images/tab/yuedu_hl.png"
      },
      {
        "text": "电影",
        "pagePath": "pages/movies/movies",
        "iconPath": "/images/tab/dianying.png",
        "selectedIconPath": "/images/tab/dianying_hl.png"
      }
    ]
  }
```

![image-20210830162740174](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830162740174.png)



#### 页面跳转

如果想要让一个普通页面，跳转到一个带有bar选项卡的页面，我们之前的逻辑是不行的了。

![image-20210830162924013](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830162924013.png)

**回顾一下，之前我们在这的跳转方式是点击按钮，进行页面的重定向，跳转到文章页面。**

![image-20210830163045023](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830163045023.png)

**这种方式现在是不能满足我们的要求了。**



#### switchTab方法的使用

使用switchTab方法，就可以从普通页面跳转到选项卡页面。

![image-20210830163310415](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830163310415.png)



## 自定义组件

要说精髓，小程序的精髓应该就是在自定义组件这里了。



### 做一个自己的自定义组件

#### 新建一个自定义组件

![image-20210830165112837](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830165112837.png)

右键点击post文件夹，然后点新建Component，就可以建好自定义组件的文件了。

一般来说，我们习惯性的让自定义组件的文件名都是index。

**这里我们就先做一个文章的自定义组件，重构一下之前的那个文章页面。**



#### 注册自定义组件

很明显，就跟我们前面使用第三方的自定义组件库一样，使用组件之前都是需要进行自定义的。

![image-20210830165856693](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830165856693.png)



#### 组件的自定义属性

##### 常规写法

在我们组件的js文件的properties属性上，我们可以**进行自定义属性的注册**。到时候使用组件的时候就可以给该属性赋值，就和**使用image标签**的时候，给src属性赋值类似的操作。

```js
/**
   * 组件的属性列表
   */
  properties: {
    // 自定义一个属性 属性名称
    text: {
      // 属性值的类型
      type: String,
      // 属性的默认值
      value: "我是默认值"
    }
  }
```

![image-20210830170751026](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830170751026.png)

**如果不给属性赋值，那么就是我们定义好的该属性的默认值**

![image-20210830170935499](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830170935499.png)





##### 简写（语法糖）

很多时候，我们觉得上面那种定义属性的方式比较麻烦。那么可以采取下面这种方式。在**没有默认值**的情况下很适用。

**这种方式定义的属性，如果属性没有传参，那么默认值就是当前属性的类型的默认值。**比如Number的默认值是0。String的默认值是空字符串

```js
/**
   * 组件的属性列表
   */
  properties: {
    // 自定义一个属性 属性名称 类型
    text: String
  }
```

**以前，普通的页面只有data里面的变量才能做数据绑定（setData定义的数据最后也会出现在data里面）**，但是，在自定义组件里，组件的属性properties和data里面出现的变量，都可以进行数据绑定。



#### 自定义属性可以接收一个Object对象

![image-20210830171959559](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830171959559.png)

前面，我们进行文章列表的遍历，来渲染整个文章页面（除去轮播图）。

我们可以发现，每篇文章的结构实际上都是相同的。**唯一不同的，只是数据而已。**

所以我们可以考虑用自定义组件来代替这个文章的结构，将结构隐藏到组件中，使页面看起来更加清爽，而且还可以达到复用的效果。

##### 封装文章组件结构/样式

我们将文章的结构和样式，都直接封装到这个自定义组件里面。

###### 结构

**结构还会进行二次更改。**

```html
<!--components/post/index.wxml-->

<view data-post-id="{{item.postId}}" class="post-container" bind:tap="onGoToDetail">
  <!-- 第一部分 作者 日期 -->
  <view class="post-author-date">
    <!-- 头像 -->
    <image class="post-author" src="{{item.avatar}}"></image>
    <text class="post-date">{{item.date}}</text>
  </view>
  <!-- 第二部分 文章标题 -->
  <text class="post-title" user-select="true">{{item.title}}</text>
  <!-- 第三部分 -->
  <image class="post-image" src="{{item.imgSrc}}"></image>
  <!-- 第四部分 文章内容 -->
  <!-- user-select 方便用户复制 -->
  <text class="post-content">{{item.content}}</text>
  <!-- 第五部分 -->
  <view class="post-like">
    <l-icon color="#666" size="28" name="favor" class="post-like-image" />
    <text class="post-like-font">{{item.collection}}</text>
    <l-icon color="#666" size="32" name="eye" class="post-like-image" />
    <text class="post-like-font">{{item.reading}}</text>
  </view>
</view>
```

###### 样式

```css
/* components/post/index.wxss */

/* 文章样式 */
.post-container {
  /* 弹性布局 */
  display: flex;
  flex-direction: column;
  margin-top: 20rpx;
  margin-bottom: 40rpx;
  background-color: #fff;
  /* 上下边框线 */
  border-top: 1rpx solid #ededed;
  border-bottom: 1rpx solid #ededed;
  padding-bottom: 10rpx;
}

/* 作者 日期样式 */
.post-author-date {
  margin: 10rpx 0 20rpx 10rpx;
  display: flex;
  flex-direction: row;
  /* flex 布局居中方案 */
  align-items: center;
}

.post-author {
  width: 60rpx;
  height: 60rpx;
  /* 头像和文字居中 */
  /* vertical-align: middle; */

}

.post-date {
  margin-left: 20rpx;
  font-size:26rpx;
  /* vertical-align: middle; */
}

/* 文章标题 */
.post-title{
  font-size:34rpx;
  font-weight: 700;
  margin-bottom: 20rpx;
  margin-left: 20rpx;
  color:#333;
}
/* 文章主图 */
.post-image{
  width: 100%;
  height: 340rpx;
  margin-bottom: 30rpx;
}
/* 文章内容 */
.post-content{
  color:#666;
  font-size: 28rpx;
  margin-bottom: 20rpx;
  margin-left: 10rpx;
  margin-right: 10rpx;
  line-height: 40rpx;
  letter-spacing: 2rpx;
  text-indent: 2em;
}
/* 文章模拟阅读量 */
.post-like{
  display: flex;
  flex-direction: row;
  margin-left: 26rpx;
  align-items: center;
}
.post-like-image{
  /* height: 32rpx;
  width: 32rpx; */
  margin-right: 16rpx;
}
.post-like-font{
  margin-right: 40rpx;
  font-size: 26rpx;
}
```



##### 自定义属性：Object类型

很明显，我们一篇文章会用到很多数据，所有使用文本进行传递是不可靠的。

这里采用传递文章对象，这个对象里面包含所有的当前文章的信息。

**那么我们就需要定义一个属性，且该属性的类型是对象类型。**

```js
/**
   * 组件的属性列表
   */
  properties: {
    // 自定义一个属性 属性名称
    postData:Object
  },
```

##### 组件结构调整

将进行数据绑定的地方进行修改。

```html
<!--components/post/index.wxml-->

<view data-post-id="{{postData.postId}}" class="post-container" bind:tap="onGoToDetail">
  <!-- 第一部分 作者 日期 -->
  <view class="post-author-date">
    <!-- 头像 -->
    <image class="post-author" src="{{postData.avatar}}"></image>
    <text class="post-date">{{postData.date}}</text>
  </view>
  <!-- 第二部分 文章标题 -->
  <text class="post-title" user-select="true">{{postData.title}}</text>
  <!-- 第三部分 -->
  <image class="post-image" src="{{postData.imgSrc}}"></image>
  <!-- 第四部分 文章内容 -->
  <!-- user-select 方便用户复制 -->
  <text class="post-content">{{postData.content}}</text>
  <!-- 第五部分 -->
  <view class="post-like">
    <l-icon color="#666" size="28" name="favor" class="post-like-image" />
    <text class="post-like-font">{{postData.collection}}</text>
    <l-icon color="#666" size="32" name="eye" class="post-like-image" />
    <text class="post-like-font">{{postData.reading}}</text>
  </view>
</view>
```

##### 使用文章自定义组件

```html
<block wx:for="{{posts}}" wx:key="postId" wx:for-item="post">
    <post post-data="{{post}}"></post>
  </block>
```

![image-20210830174933350](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830174933350.png)

**可以看见，文章被成功的渲染出来了。**



#### 自定义组件的事件

这里，我们简单的把当时进行点击文章，调整到对应的文章详情页的方法代码，抽离到自定义组件中。

组件使用到的放到，都需要在methods属性里面进行定义。

![image-20210830175752019](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830175752019.png)





### 自定义组件-movie-list

**这里将自定义一个展示电影列表的自定义组件。**

![image-20210830202641102](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830202641102.png)







![image-20210830180105559](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830180105559.png)



组件建立好了以后就**在电影页面movies**里面进行组件的注册。

![image-20210830180350540](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830180350540.png)



**测试**：发现正常引入

![image-20210830180548725](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830180548725.png)



### 组件的嵌套

我们可以发现，**每个电影实际上也是结构相同，只是数据不同而已**。所以我们可以把电影也抽成一个组件。



#### 电影组件-movie

![image-20210830181255465](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830181255465.png)







#### 组件的制作

我们前面说过，开发页面的时候，可以先用假数据模拟，然后等静态页面制作好了以后，再将假数据替换为我们实际从服务器请求的数据。

**组件的**开发也是一样，先用假数据，然后在替换为实际使用组件时，外界传递进来的数据。

**在movie-list组件**内部，我们会使用 **movie**组件，那么这就构成了组件之间的相互嵌套。

##### 组件嵌套的使用

###### 注册

在movie-list组件内组成movie组件

![image-20210830181601571](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830181601571.png)

###### 使用movie组件

在组件内部使用其他组件，也是和普通标签一样使用。

![image-20210830181747226](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830181747226.png)







#### movie组件的制作

##### 静态模板的制作

这一步，比较简单，没什么好说的。

```html
<!--components/movie/index.wxml-->
<!-- 电影容器 -->
<view class="container">
  <!-- 电影海报 -->
  <image class="poster" src="/images/img1.jpg"></image>
  <!-- 电影标题 -->
  <text class="title">小米手机哈哈哈哈哈哈哈</text>
</view>
```

##### 静态模板的css

```css
/* components/movie/index.wxss */

/* 容器 */
.container {
  display: flex;
  width: 200rpx;
  flex-direction: column;
}

/* 电影海报 */
.poster {
  width: 100%;
  height: 270rpx;
  margin-bottom: 22rpx;
}

/* 标题 */
.title {
  /* 标题字数过长 多出的隐藏 */
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  word-break: break-all;
}
```

##### 静态模板效果



![image-20210830204133639](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830204133639.png)



##### 使用lin-ui的评分组件

这个评分的组件，我们自己制作的话是比较麻烦的，所以直接使用第三方提供好的。（**如果想要自己实现其实也不是很难，只实现整数性质的平分还是比较容易的。**）

###### l-rate评分组件的注册

![image-20210830204453700](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830204453700.png)

##### 使用l-rate继续完成movie组件



![image-20210830210043421](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830210043421.png)

```html
<view class="rate-container">
    <!-- 评分 -->
    <!-- score属性 显示点亮多少星星 可以是小数 -->
    <!-- 星星的大小 size 进行设置 -->
    <!-- 使用count属性可以修改星星的数量（默认是五个星） -->
    <!-- 设置禁用点击 disabled="true" -->
    <!-- 使用active-color属性 可以修改点亮的星星的颜色 -->
    <!-- 使用 inActive-color 属性 可以修改未选中的星星颜色 -->
    <l-rate disabled="{{true}}" score="3.6" size="22" />
    <!-- 显示评分 -->
    <text class="score">3.6</text>
  </view>
```

```css
/* 评分容器 */
.rate-container{
  margin-top: 6rpx;
  display: flex;
  flex-direction: row;
  /* 基线对齐 */
  align-items: baseline;
}
.score{
  margin-left: 16rpx;
  font-size: 24rpx;
}
```



#### movie-list组件的制作

通过开始的图片我们看见了，一个movie-list组件里面是有三个电影组件的。

所以接下来我们要利用制作好的movie组件来制作我们的movie-list组件了。

```html
<!--components/movie-list/index.wxml-->

<view class="container">
  <view class="title-container">
    <text>正在热映</text>
    <text class="more-text">更多 ></text>
  </view>
  <!-- 组件的嵌套 -->
  <view class="movie-container">
    <movie />
    <movie />
    <movie />
  </view>
</view>
```

```css
/* components/movie-list/index.wxss */
/* 组件容器 */
.container {
  padding: 36rpx 28rpx;
}

/* 标题容器 */
.title-container {
  display: flex;
  flex-direction: row;
  /* 主轴排列方式 两端对齐*/
  justify-content: space-between;
  margin-bottom: 26rpx;
}
.more-text{
  color:#1f4ba5;
}

/* 海报组件容器 */
.movie-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}
```

**静态的制作都是挺简单的，先用死数据，制作好样式，后期在替换就完事。**

![image-20210830212121035](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830212121035.png)

##### 使用多个movie-list组件

效果看起来也还可以。但是样式还需要进行调整。

![image-20210830212302788](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830212302788.png)



##### 设置组件的样式

我们在使用movie-list组件的时候，感觉这个样式并不完美，想要给这个组件加一些样式，但是，遇见了一些问题，就是给这个组件设置的样式都不生效。

![image-20210830213440059](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830213440059.png)

直接用组件的名称设置样式，或者给组件添加class类名设置样式，都不生效。

这是为什么呢？

##### 解决movie-list样式不生效

想要解决样式不生效的问题，我们这里需要使用组件的**外部样式类**。

**之所以使用外部样式，是因为我们使用的组件，并不知道我们实际上会设置什么样式，所以定义好类名交给我们外部进行设置，到时候通过外部样式的入口进行传递给组件引用，完成样式的设置。**

外部样式类的使用也比较简单。

![image-20210830215344883](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830215344883.png)

很明显，可以看见第一个设置外部样式的颜色发生了改变。

![image-20210830215541605](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830215541605.png)



**这种直接给自定义组件设置样式不生效的问题，是由小程序内部的机制引起的。这时候我们就需要考虑使用外部样式类了。**



#### movie-list组件的优化

##### 动态标题

前面我们将所有的数据都是按照死数据来定死的。实际上这肯定是不合理的。这里进行标题的动态赋值。

我们在组件的js文件中设置这个属性。让外界动态的传参。

![image-20210830220442697](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830220442697.png)



```js
/**
   * 组件的属性列表
   */
  properties: {
    title:String
  },
```

![image-20210830220715789](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210830220715789.png)



### 小程序请求服务端数据

#### 发起请求wx.request方法

常规用法，请求地址加上回调函数

```js
// 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: 'url',
      // 请求方式 默认就是get请求
      method:"GET",
      success(res){
        console.log(res);
      }
    })
```

#### 获取请求数据

```js
// 别忘了获取全局app
const app = getApp()
/**
   * 页面的初始数据
   */
  data: {
    // 正在热映的电影数据
    inTheaters:[],
    // 即将上映的电影数据
    comingSoon:[],
    // top250
    top250:[]
  },
/**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    // 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: app.gBaseUrl+'in_theaters',
      method: "GET",
      // 参数 在get请求中为查询字符串
      data: {
        // 电影的起始索引
        start: 0,
        // 电影的总条数
        count: 3
      },
      success:(res) =>{ // 使用箭头函数解决this指向问题
        // 电影数据
        console.log(res.data.subjects);
        this.setData({
          inTheaters:res.data.subjects
        })
      }
    });

    // 即将上映的数据
    wx.request({
      // 请求地址
      url: app.gBaseUrl+'coming_soon',
      method: "GET",
      data: {
        start: 0,
        count: 3
      },
      success:(res) =>{ 
        // console.log(res);
        this.setData({
          comingSoon:res.data.subjects
        })
      }
    });
    // top250
    wx.request({
      // 请求地址
      url: app.gBaseUrl+'top250',
      method: "GET",
      data: {
        start: 0,
        count: 3
      },
      success:(res) =>{ 
        this.setData({
          top250:res.data.subjects
        })
      }
    })

  },
```

#### 将数据绑定到movie-list组件

```html
<!--pages/movies/movies.wxml-->

<movie-list movies="{{inTheaters}}" title="正在热映" l-class="movie-list" />
<movie-list movies="{{comingSoon}}" title="正在上映" l-class="movie-list" />
<movie-list movies="{{top250}}" title="豆瓣Top250" l-class="movie-list" />
```



#### movie-list组件数据的替换

现在，数据已经传递进来了，我们要做的就是动态替换实际的电影列表数据，并将**每个电影的数据传递给电影组件**。

![image-20210831083904536](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210831083904536.png)



#### movie组件的数据替换

接下来将movie组件的死数据替换为真实数据即可。

![image-20210831084105206](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210831084105206.png)



#### 效果

![image-20210831084148756](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210831084148756.png)

有些图片加载不出来，和星星显示有误很正常，毕竟不是我们自己写的服务端数据。肯定会出现数据图片等有问题的错误。





# 微信小程序入门(七)--入门篇完结



### 实现电影页面按钮的更多功能

![image-20210901094428669](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901094428669.png)



点击更多按钮，进入电影的更多页面。

**所以我们接下来就先获取到请求的数据，来构建更多电影页面。**



#### 获取数据

![image-20210901105620511](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901105620511.png)



```js
/**
   * 页面的初始数据
   */
  data: {
    // 电影集合
    movies:[]
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: app.gBaseUrl + 'in_theaters',
      method: "GET",
      // 参数 在get请求中为查询字符串
      data: {
        // 电影的起始索引
        start: 0,
        // 电影的总条数
        count: 12
      },
      success: (res) => { // 使用箭头函数解决this指向问题
        // 电影数据
        console.log(res.data.subjects);
        this.setData({
          movies: res.data.subjects
        })
      }
    });
  },
```

![image-20210901132458764](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901132458764.png)





#### more-movie页面布局

![image-20210901134323343](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901134323343.png)

```css
/* pages/more-movie/more-movie.wxss */
/* 容器 */
.container {
  display: flex;
  flex-direction: row;
  /* 排列不下的时候，自动换行 */
  flex-wrap: wrap;
  padding: 30rpx 28rpx;
  justify-content: space-between;
}

.movie {
  margin-bottom: 26rpx;
}
```

**这里，我们可以发现，并没有用外部样式类来设置组件的样式，而是直接给组件添加样式类，设置的样式也生效。这里的生效原因应该是这个组件被view标签进行了包裹，所以设置的样式才会生效，如果没有被其他标签包裹，而是一个单独的标签，应该是设置样式不会生效，除非使用外部样式类。**

像下面这种就不会生效。

```html
<movie class="movie" movie="{{movie}}" />
```



#### movies页面更多按钮绑定事件

![image-20210901135014871](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901135014871.png)

在每个电影列表上都绑定好当前所属的列表类型。用自定义属性进行绑定。

![image-20210901135603377](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901135603377.png)

##### 更多按钮的事件

通过event事件属性取到我们在当前元素上自定义的属性，进行页面跳转的时候，将电影类型一并传过去，方法更多电影页面发起请求。

```js
/**
   * 页面跳转
   * @param {*} event 
   */
  onGoToMore(event) {
    // 类型
    const type = event.currentTarget.dataset.type;
    // 跳转到更多页面 以子页面的形式打开
    wx.navigateTo({
      url: "/pages/more-movie/more-movie?type="+type
    })
  }
```



##### 更多页面onLoad的更改

需要请求的具体电影列表，通过type属性进行接收。

```js
/**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 获取电影列表类型
    const type = options.type;
    // 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: app.gBaseUrl + type,
      method: "GET",
      // 参数 在get请求中为查询字符串
      data: {
        // 电影的起始索引
        start: 0,
        // 电影的总条数
        count: 12
      },
      success: (res) => { // 使用箭头函数解决this指向问题
        // 电影数据
        console.log(res.data.subjects);
        this.setData({
          movies: res.data.subjects
        })
      }
    });
  },
```



#### 实现movies电影页面的搜索功能

直接使用**lin-ui**小程序组件库进行开发。方便快捷，没什么写的必要。

##### 注册组件

```json
{
  "usingComponents": {
    "movie-list":"/components/movie-list/index",
    "l-search-bar":"/miniprogram_npm/lin-ui/search-bar/index"
  }
}
```



##### 使用

```html
<!-- 搜索栏 -->
<!-- bg-color属性 更改背景颜色 -->
<!-- 我们这里使用该组件提供好的外部样式类，进行样式的更改，修改高度 -->
<!-- 这些东西官网都有说明 -->
<!-- 使用show-cancel属性 可以取消 右侧的取消按钮及其事件 -->
<l-search-bar l-class="ex-search-bar" placeholder="请输入您想看的电影" />
```

```css
/* 外部样式类 */
.ex-search-bar {
  /* 可能发生了样式冲突，所以我们需要提高优先级 */
  height: 90rpx !important;
}
```





![image-20210901141433978](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901141433978.png)



![image-20210901141517765](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901141517765.png)





## 上滑加载更多电影数据

我们每次请求的数据，默认的条数都是12条，所以用户可能一会就滑到了最底部，其实，小程序的生命周期里面，提供的有关于滑到到页面底部的回调函数。

![image-20210901142611984](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901142611984.png)

可以看见，只要你滑动到最底部，我们在这个函数里面写的代码就会被打印。说明该函数的确是执行了。

![image-20210901142725171](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901142725171.png)

**所以我们可以在这个函数里面书写继续发起请求电影列表的代码。**



##### 加载更多电影数据

将前面我们在onLoad方法里面拿到的type值，也就是电影列表的类型进行保存。

![image-20210901144912320](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901144912320.png)



**发起请求获取数据**

代码逻辑都写在页面上啦触底事件的生命周期函数中。

```js
/**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    // 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: app.gBaseUrl + this.data._type,
      method: "GET",
      // 参数 在get请求中为查询字符串
      data: {
        // 电影的起始索引
        start: this.data.movies.length,
        // 电影的总条数
        count: 12
      },
      success: (res) => { // 使用箭头函数解决this指向问题
        // 电影数据
        this.setData({
          // 追加数据
          movies: [...this.data.movies, ...res.data.subjects]
        });
      }
    });
  }
```



### 提示用户数据请求中

我们在发起请求获取新的电影数据的时候，很可能出现用户多次发起请求，但是此时网络情况并不好，这时候页面的刷新就比较慢，**这时候我们就需要提醒用户页面数据正在刷新。用小程序的内置组件就可以完成这种轻提示。**

我们的目的就是，数据请求过程中，页面还没刷新完毕的时候，提示用户正在加载，一旦数据请求成功并且页面开始刷新了，就不应该还继续提示用户正在加载数据。

![image-20210901150131517](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901150131517.png)



只需要添加显示和隐藏加载动画的提示框即可。

```js
/**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    // 请求数据前 提示用户正在加载数据 刷新页面 显示加载动画
    wx.showNavigationBarLoading();

    // 请求服务器数据 获取正在热映的电影
    wx.request({
      // 请求地址
      url: app.gBaseUrl + this.data._type,
      method: "GET",
      // 参数 在get请求中为查询字符串
      data: {
        // 电影的起始索引
        start: this.data.movies.length,
        // 电影的总条数
        count: 12
      },
      success: (res) => { // 使用箭头函数解决this指向问题
        // 电影数据
        this.setData({
          // 追加数据
          movies: [...this.data.movies, ...res.data.subjects]
        });

        // 电影数据请求完毕了，隐藏正在加载的提示框动画
        wx.hideNavigationBarLoading()
      }
    });
  },
```

![image-20210901150318850](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901150318850.png)





## 下拉刷新数据

### 开启页面的下拉刷新

```json
{
  "usingComponents": {
    "movie":"/components/movie/index"
  },
    // 开启下拉刷新
  "enablePullDownRefresh": true
}
```

如果在app.json里面配置这个的话，那么在所有的页面都可以进行下来是刷新了。



![image-20210901152450885](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901152450885.png)



### 监听用户下拉动作

小程序默认给我们提供好的有小程序页面监听下拉动作的函数。

![image-20210901153626697](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901153626697.png)

### 实现下拉刷新

这个就比较简单了，直接一段代码搞定。获取数据以后，调用wx.stopPullDownRefresh()方法，停止下拉的动作。

```js
/**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    // 用户进行下拉以后，我们就刷新数据
    wx.request({
      url: app.gBaseUrl + this.data._type,
      data: {
        start: 0,
        count: 12
      },
      success: (res) => {
        this.setData({
          movies: res.data.subjects
        })
        // 关闭我们的下拉刷新动画
        wx.stopPullDownRefresh();
      }
    })
  }
```





## 增强阅读页面效果

### 配置标题与动态配置标题

#### 配置标题

**使用小程序全局的window对象里面的navigationBarTitleText属性，**设置导航栏的标题。

```json
"navigationBarTitleText": "光与影"
```

但是这样配置的标题是死标题，而且，还不能动态的改变，对于组件来说，这样配置无疑是没什么用的。我们应该让这个标题是动态的。

![image-20210901161053852](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901161053852.png)





#### 动态配置标题

很明显，动态配置标题是不可获取的，对于这种常用的功能，小程序基本都帮我们提供好了。

**使用小程序的wx.setNavigationBarTitle**方法就可以动态的设置我们想设置的标题了。

![image-20210901161503637](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901161503637.png)

我们将这部分动态设置标题的代码写在onReady生命周期中，页面只有第一次加载才需要设置标题的。

```js
/**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    let title = "电影";
    // 根据类型渲染不同的标题
    switch (this.data._type) {
      case "in_theaters":
        title = "正在热映";
        break;
      case "coming_soon":
        title = "即将上映";
        break;
      case "top250":
        title = "Top250";
        break;
    }
    wx.setNavigationBarTitle({
      title
    })
  }
```





## 电影详情页



### 组件的独立性



#### 对post组件进行改进

开始，我们是将点击文章，去文章详情页的点击事件的回调函数，直接写死在了组件上，这肯定是不合理的。因为不可能每个人用组件，点击之后的操作都是同样的。所以回调函数的执行应该让外界传递。提高组件的复用性，让组件与事件的具体执行操作独立开来。这就是组件的独立性。



##### 发射事件

![image-20210901172629488](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901172629488.png)

当然，携带的参数也不一定非要通过当前事件的目标对象身上的属性来获取，毕竟我们组件上其实已经有这一篇文章的全部信息了。

![image-20210901173604854](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901173604854.png)



##### 接收事件

![image-20210901172743182](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901172743182.png)

这种做功能一样还是正常实现，但是提高了组件的可复用性。



#### 文章页面问题修正

虽然我们上面那种做法，提高了组件的复用性。但是现在带来了新的问题，那就是我们点击图片是无法完成跳转了。

##### 方式一

最简单的方式当然是直接在写一个方法，按照之前的逻辑就完事。简单易懂。



##### 方式二

我们可以还是在一个方法里面实现点击上面轮播图实现正常跳转。

```js
// event  事件
  onGoToDetail(event) {
    // console.log(event.type); // 可以获取触发的事件类型
    let pid = event.currentTarget.dataset.postId;
    if (!pid) {
      // 没有获取到，说明是点击文章进行跳转的
      pid = event.detail.pid;
    }
    wx.navigateTo({
      // 跳转文章详情页 event.detail.pid 可以拿到我们组件发射事件时携带的参数
      url: "/pages/post-detail/post-detail?pid=" + pid,
    })
  }
```





### 电影详情页的制作

#### 给自定义组件movie绑定事件

为了开发方便，这里我是讲业务代码封装了一部分在组件上，实际上一个好的组件不应该这样，这里是因为这是我们自己写的业务组件，纯粹是为了自己方便，所以可以这样做。

![image-20210901191651266](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901191651266.png)

在点击每个电影，都可以去往电影详情页。而且携带了当前电影的id号。

![image-20210901191749501](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901191749501.png)



#### 根据id请求电影数据

根据mid，向服务器发起请求，获取当前电影的详情数据。

![image-20210901192622268](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901192622268.png)



#### 绑定数据

![image-20210901192823290](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901192823290.png)





#### 详情页的制作



##### 详情页头部区域

前面我们已经获取到每个电影详情页的电影详情数据。接下来开始电影详情的头部制作。

**骨架**

```html
<!--pages/movie-detail/movie-detail.wxml-->
<view class="container">
  <!-- 头部大图(做模糊效果) -->
  <image class="head-img" src="{{movie.images.large}}"></image>
  <!-- 头部标题，副标题 -->
  <view class="head-image-hover">
    <text class="main-title">{{movie.title}}</text>
    <text class="sub-title">{{movie.countries[0] + " · " +movie.year}}</text>

    <!-- 多少人想看，多少人喜欢 -->
    <view class="like">
      <text class="highlight-font">{{movie.wish_count}}</text>
      <text class="plain-font">人喜欢</text>
      <text class="highlight-font">{{movie.comments_count}}</text>
      <text class="plain-font">条评论</text>
    </view>
    <!-- 电影海报 -->
    <image class="movie-image" src="{{movie.images.large}}"></image>
  </view>

</view>
```

**样式**

```css
/* pages/movie-detail/movie-detail.wxss */

/* 容器 */
.container {
  display: flex;
  flex-direction: column;
}

/* 头部海报 做模糊效果图 */
.head-img {
  width: 100%;
  height: 320rpx;
  /* 模糊效果 */
  filter: blur(18px);
}
/* 标题 */
.head-image-hover{
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 320rpx;
  position: absolute;
}
.main-title{
  font-size:38rpx;
  color:#fff;
  font-weight: bold;
  letter-spacing: 2px;
  margin-top: 50rpx;
  margin-left: 40rpx;
}
.sub-title{
  font-size: 28rpx;
  color:#fff;
  margin-top: 30rpx;
  margin-left: 40rpx;
}
.like{
  display: flex;
  flex-direction: row;
  margin-top: 30rpx;
  margin-left: 40rpx;
}
/* 数字高亮 */
.highlight-font{
  color:#f21146;
  font-size: 22rpx;
  font-weight: 600;
  margin-right: 10rpx;
}
.plain-font{
  color:#666;
  font-size: 22rpx;
  margin-right: 30rpx;
}


/* 电影海报 */
.movie-image {
  position: absolute;
  top: 160rpx;
  right: 30rpx;
  height: 238rpx;
  width: 175rpx;
}
```

**效果**

![image-20210901205540785](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901205540785.png)

没错，是我要的。



##### 头部电影海报(预览)

做小程序的海报放大方式，也就是我们所说的预览。小程序原生给我们提供的有这种方法。

![image-20210901211056877](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901211056877.png)

```js
/**
   * 图片预览
   * @param {*} event 
   */
  onViewPost(event) {
    wx: wx.previewImage({
      // 预览的图片，可以有多个 值是src的值 也就是链接地址
      urls: [this.data.movie.images.large],
      // 当前预览的第一张图片
      current: this.data.movie.images.large
    })
  }
```

**大部分功能基本上小程序都内置过了。想要做什么效果，建议第一件事是去文档查一下有没有。**

![image-20210901211352153](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901211352153.png)





#### 图片的mode模式

[图片的mode模式，懂的都懂](https://developers.weixin.qq.com/miniprogram/dev/component/image.html)

默认不设置的模式：

![image-20210901212027581](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901212027581.png)

设置mode**模式为aspectFill**时：

![image-20210901212121039](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901212121039.png)

很明显，可以看出图片没有被拉伸。

**当然，mode模式的值很多，可以去官网多看看**

![image-20210901212313363](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901212313363.png)





#### 电影详情页建议简介部分

##### 数据的预处理

![image-20210901213932843](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901213932843.png)

可以看见，我们获取到数据，很多都是数组，不便于页面的数据展示，所以需要对数据进行预处理。

##### 封装一个工具函数

该函数用来处理导演和演员数组，拼接元素的name属性。

```js
/**
 * 将数组元素里面的name属性转为字符串拼接 
 * @param {*} casts 数组 可以拼接演员和导演数组的name
 */
export function convertToCastString(casts) {
  const names = [];
  casts.forEach(item => {
    names.push(item.name);
  })
  return names.join(" / ");
}
```

##### 数据的处理

对数据进行预处理，方便页面进行更好的展示

```js
// pages/movie-detail/movie-detail.js
// 导入util工具
import { convertToCastString } from "../../utils/util.js"
const app = getApp()
Page({

  /**
   * 页面的初始数据
   */
  data: {
    // 电影详情数据
    movie: {}
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    wx.request({
      // 获取电影详细数据
      url: app.gBaseUrl + "subject/" + options.mid,
      method: "GET",
      success: (res) => {
        console.log(res.data);
        // 电影数据预处理
        this.processMovieData(res.data);
        // 数据绑定 方法处理好数据以后，内部绑定
      }
    })
  },
  /**
   * 图片预览
   * @param {*} event 
   */
  onViewPost(event) {
    wx: wx.previewImage({
      // 预览的图片，可以有多个 值是src的值 也就是链接地址
      urls: [this.data.movie.image],
      // 当前预览的第一张图片
      current: this.data.movie.image
    })
  },
  /**
   * 对请求的电影数据进行预处理
   * @param {*} movie 电影数据
   */
  processMovieData(movie) {
    // 处理后的数据
    const movieData = {};
    // 处理导演和演员数组
    movieData.directorsStr = convertToCastString(movie.directors);
    movieData.castsStr = convertToCastString(movie.casts);
    // 图片处理一下
    movieData.image = movie.images.large;
    // 标题处理
    movieData.title = movie.title;
    // 副标题
    movieData.sub_title = movie.countries[0] + " · " + movie.year;
    movieData.wishCount = movie.wish_count;
    movieData.commentsCount = movie.comments_count;
    movieData.originalTitle = movie.original_title;
    // 评分
    movieData.score = movie.rating.stars / 10;
    movieData.average = movie.rating.average;
    movieData.genresStr = movie.genres.join(" / ");
    // 数据绑定
    this.setData({
      movie: movieData
    })
  }
})
```



##### 页面数据展示

这里只截取了其中的电影简介部分。也就是我们当前写的这一部分。

```html
 <!-- 电影简介 -->
  <view class="summary">
    <!-- 起始标题 -->
    <view class="orgin-title">
      <text>{{movie.originalTitle}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">评分</text>
      <!-- lin-ui的评分组件 -->
      <view class="score-container">
        <l-rate size="22" disabled="{{true}}" score="{{movie.score}}"></l-rate>
        <text class="average">{{movie.average}}</text>
      </view>
    </view>
    <view class="flex-row">
      <text class="mark">导演</text>
      <!-- 导演可能有多个，需要进行数据处理 -->
      <text>{{movie.directorsStr}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">影人</text>
      <!-- 影人也需要进行数据处理，也是数组 -->
      <text>{{movie.castsStr}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">类型</text>
      <!-- 一般类型也是数组，都需要进行对原始处理 -->
      <text>{{movie.genresStr}}</text>
    </view>
  </view>
<!-- 分割线 -->
<view class="hr"></view>
```



##### 电影简介的样式书写

```css
/* 电影简介 */
.summary {
  margin-left: 40rpx;
  margin-top: 40rpx;
  color: #777;
}

.orginal-title {
  color: #1f3463;
  font-size: 24rpx;
  font-weight: bold;
  margin-bottom: 40rpx;
}

.flex-row {
  display: flex;
  flex-direction: row;
  align-items: baseline;
  margin-bottom: 10rpx;
}
.score-container {
  display: flex;
  flex-direction: row;
  align-items: baseline;
}
.average{
  margin-left: 20rpx;
}


.mark {
  margin-right: 30rpx;
  /* 不换行 */
  white-space: nowrap;
  color: #999;
}
/* 水平线 */
.hr{
  width: 100%;
  height: 1px;
  margin-top: 50rpx;
  background-color: #d9d9d9;
}
```

##### 效果

![image-20210901223856720](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901223856720.png)

#### 电影剧情简介

没啥好说的，都简单了

##### 结构

```html
  <!-- 剧情简介 -->
  <view class="synopsis">
    <text class="synopsis-font">剧情简介</text>
    <text class="summary-content">{{movie.summary}}</text>
  </view>
  <view class="hr"></view>
```

##### 样式

```css
/* 剧情简介样式 */
.synopsis{
  margin-left: 40rpx;
  display: flex;
  flex-direction: column;
  margin-top: 50rpx;
}
.synopsis-font{
  font-size: 32rpx;
  color:#999;
}

.summary-content{
  margin-top: 20rpx;
  margin-right: 40rpx;
  line-height: 40rpx;
  letter-spacing: 1px;
  text-indent: 2em;
}
```



#### 影人部分制作

这个部分其实有点难。**好好看好好学**

##### 增加的数据预处理部分

```js

/**
 * 将数组元素里面的name属性转为字符串拼接 
 * @param {*} casts 数组 可以拼接演员和导演数组的name
 */
export function convertToCastString(casts) {
  const names = [];
  casts.forEach(item => {
    names.push(item.name);
  })
  return names.join(" / ");
}
/**
 * 整合影人的信息 图片和名字
 * @param {*} casts 
 */
export function convertToCastInfos(casts) {
  const castsArray = [];
  casts.forEach(item => {
    castsArray.push({
      img: item.avatars?.large,
      name: item.name
    })
  })
  return castsArray;
}
```

```js
/**
   * 对请求的电影数据进行预处理
   * @param {*} movie 电影数据
   */
  processMovieData(movie) {
    // 处理后的数据
    const movieData = {};
    // 处理导演和演员数组
    movieData.directorsStr = convertToCastString(movie.directors);
    movieData.castsStr = convertToCastString(movie.casts);
    // 图片处理一下
    movieData.image = movie.images.large;
    // 标题处理
    movieData.title = movie.title;
    // 副标题
    movieData.sub_title = movie.countries[0] + " · " + movie.year;
    movieData.wishCount = movie.wish_count;
    movieData.commentsCount = movie.comments_count;
    movieData.originalTitle = movie.original_title;
    // 评分
    movieData.score = movie.rating.stars / 10;
    movieData.average = movie.rating.average;
    movieData.genresStr = movie.genres.join(" / ");
    movieData.summary = movie.summary;
    // 处理影人数据
    movieData.castsInfo = convertToCastInfos(movie.casts);
    // 数据绑定
    this.setData({
      movie: movieData
    })
  }
```



##### 结构

```html
<!-- 影人简介 -->
  <view class="casts">
    <!-- 标题 -->
    <text class="cast-font">影人</text>
    <view class="casts-container">
      <!-- 列表循环 展示影人数据 -->
      <block wx:for="{{movie.castsInfo}}" wx:key="index">
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
        <!-- 模拟多个影人数据，让一个影人出现三次，做图片的滑动效果 -->
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
      </block>
    </view>
  </view>
```



##### 样式

```css
/* 影人简介布局 */
.casts{
  display: flex;
  flex-direction: column;
  margin-top: 50rpx;
  margin-left: 40rpx;

}
.casts-container{
  display: flex;
  flex-direction: row;
}
.cast-container{
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-right: 40rpx;
  margin-bottom: 60rpx;
}
.cast-img{
  width: 170rpx;
  height: 210rpx;
  margin-bottom: 12rpx;
}
.cast-font{
  color:#999;
  margin-bottom: 40rpx;
}
```



#### 滑动效果

##### 小程序的滑动组件

小程序提供的内置组件里面有scroll-view组件，可以用来替换view组件。

提供这个标签，可以进行横向的滑动，做成可滚动的视图区域。

[你想要的scroll-view这都有](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)

![image-20210901232227835](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901232227835.png)

##### 效果

![image-20210901232321718](https://gitee.com/maolovecoding/picture/raw/master/images/web/wei_chat/image-20210901232321718.png)

### 电影详情页完整代码

#### 结构

```html
<!--pages/movie-detail/movie-detail.wxml-->
<view class="container">
  <!-- 头部大图(做模糊效果) -->
  <!-- 图片的填充模式，默认的填充模式，在我们不知道图片比例的情况下，一般设置宽高撑满，容易出现变形。拉伸 -->
  <!-- mode="aspectFill" 设置这个值，会保持原来图片的比例进行缩放，可以保证某一个方向是完整的，另一个方向被裁减 -->
  <image mode="aspectFill" class="head-img" src="{{movie.image}}"></image>
  <!-- 头部标题，副标题 -->
  <view class="head-image-hover">
    <text class="main-title">{{movie.title}}</text>
    <text class="sub-title">{{movie.sub_title}}</text>

    <!-- 多少人想看，多少人喜欢 -->
    <view class="like">
      <text class="highlight-font">{{movie.wishCount}}</text>
      <text class="plain-font">人喜欢</text>
      <text class="highlight-font">{{movie.commentsCount}}</text>
      <text class="plain-font">条评论</text>
    </view>
    <!-- 电影海报 -->
    <!-- 点击图片实现放大效果 -->
    <image bind:tap="onViewPost" class="movie-image" src="{{movie.image}}"></image>
  </view>

  <!-- 电影简介 -->
  <view class="summary">
    <!-- 起始标题 -->
    <view class="orgin-title">
      <text>{{movie.originalTitle}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">评分</text>
      <!-- lin-ui的评分组件 -->
      <view class="score-container">
        <l-rate size="22" disabled="{{true}}" score="{{movie.score}}"></l-rate>
        <text class="average">{{movie.average}}</text>
      </view>
    </view>
    <view class="flex-row">
      <text class="mark">导演</text>
      <!-- 导演可能有多个，需要进行数据处理 -->
      <text>{{movie.directorsStr}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">影人</text>
      <!-- 影人也需要进行数据处理，也是数组 -->
      <text>{{movie.castsStr}}</text>
    </view>
    <view class="flex-row">
      <text class="mark">类型</text>
      <!-- 一般类型也是数组，都需要进行对原始处理 -->
      <text>{{movie.genresStr}}</text>
    </view>
  </view>
  <!-- 分割线 -->
  <view class="hr"></view>

  <!-- 剧情简介 -->
  <view class="synopsis">
    <text class="synopsis-font">剧情简介</text>
    <text class="summary-content">{{movie.summary}}</text>
  </view>
  <view class="hr"></view>


  <!-- 影人简介 -->
  <view class="casts">
    <!-- 标题 -->
    <text class="cast-font">影人</text>
    <!-- scroll-x="{{true}}" 表示进行横向滚动 -->
    <!-- enable-flex = {{true}} 表示重新支持flex布局，scroll-view组件默认是不支持flex布局的，需要开启 -->
    <scroll-view enable-flex="{{true}}" scroll-x="{{true}}" class="casts-container">
      <!-- 列表循环 展示影人数据 -->
      <block wx:for="{{movie.castsInfo}}" wx:key="index">
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
        <!-- 模拟多个影人数据，让一个影人出现三次，做图片的滑动效果 -->
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
        <view class="cast-container">
          <image class="cast-img" src="{{item.img}}"></image>
          <text>{{item.name}}</text>
        </view>
      </block>
    </scroll-view>
  </view>
</view>
```

#### 样式

```css
/* pages/movie-detail/movie-detail.wxss */

/* 容器 */
.container {
  display: flex;
  flex-direction: column;
}

/* 头部海报 做模糊效果图 */
.head-img {
  width: 100%;
  height: 320rpx;
  /* 模糊效果 */
  filter: blur(18px);
}

/* 标题 */
.head-image-hover {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 320rpx;
  position: absolute;
}

.main-title {
  font-size: 38rpx;
  color: #fff;
  font-weight: bold;
  letter-spacing: 2px;
  margin-top: 50rpx;
  margin-left: 40rpx;
}

.sub-title {
  font-size: 28rpx;
  color: #fff;
  margin-top: 30rpx;
  margin-left: 40rpx;
}

.like {
  display: flex;
  flex-direction: row;
  margin-top: 30rpx;
  margin-left: 40rpx;
}

/* 数字高亮 */
.highlight-font {
  color: #f21146;
  font-size: 22rpx;
  font-weight: 600;
  margin-right: 10rpx;
}

.plain-font {
  color: #666;
  font-size: 22rpx;
  margin-right: 30rpx;
}


/* 电影海报 */
.movie-image {
  position: absolute;
  top: 160rpx;
  right: 30rpx;
  height: 238rpx;
  width: 175rpx;
}

/* 电影简介 */
.summary {
  margin-left: 40rpx;
  margin-top: 40rpx;
  color: #777;
}

.orginal-title {
  color: #1f3463;
  font-size: 24rpx;
  font-weight: bold;
  margin-bottom: 40rpx;
}

.flex-row {
  display: flex;
  flex-direction: row;
  align-items: baseline;
  margin-bottom: 10rpx;
}
.score-container {
  display: flex;
  flex-direction: row;
  align-items: baseline;
}
.average{
  margin-left: 20rpx;
}


.mark {
  margin-right: 30rpx;
  /* 不换行 */
  white-space: nowrap;
  color: #999;
}
/* 水平线 */
.hr{
  width: 100%;
  height: 1px;
  margin-top: 50rpx;
  background-color: #d9d9d9;
}

/* 剧情简介样式 */
.synopsis{
  margin-left: 40rpx;
  display: flex;
  flex-direction: column;
  margin-top: 50rpx;
}
.synopsis-font{
  font-size: 32rpx;
  color:#999;
}

.summary-content{
  margin-top: 20rpx;
  margin-right: 40rpx;
  line-height: 40rpx;
  letter-spacing: 1px;
  text-indent: 2em;
}

/* 影人简介布局 */
.casts{
  display: flex;
  flex-direction: column;
  margin-top: 50rpx;
  margin-left: 40rpx;

}
.casts-container{
  display: flex;
  flex-direction: row;
  /* margin-bottom: 50rpx; */
  height: 300rpx;
}
.cast-container{
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-right: 40rpx;
  margin-bottom: 40rpx;
}
.cast-img{
  width: 170rpx;
  height: 210rpx;
  margin-bottom: 12rpx;
}
.cast-font{
  color:#999;
  margin-bottom: 40rpx;
}
```

#### 行为

```js
// pages/movie-detail/movie-detail.js
// 导入util工具
import { convertToCastString,convertToCastInfos } from "../../utils/util.js"
const app = getApp()
Page({

  /**
   * 页面的初始数据
   */
  data: {
    // 电影详情数据
    movie: {}
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    wx.request({
      // 获取电影详细数据
      url: app.gBaseUrl + "subject/" + options.mid,
      method: "GET",
      success: (res) => {
        console.log(res.data);
        // 电影数据预处理
        this.processMovieData(res.data);
        // 数据绑定 方法处理好数据以后，内部绑定
        // this.setData({
        //   movie: res.data
        // })
      }
    })
  },
  /**
   * 图片预览
   * @param {*} event 
   */
  onViewPost(event) {
    wx: wx.previewImage({
      // 预览的图片，可以有多个 值是src的值 也就是链接地址
      urls: [this.data.movie.image],
      // 当前预览的第一张图片
      current: this.data.movie.image
    })
  },
  /**
   * 对请求的电影数据进行预处理
   * @param {*} movie 电影数据
   */
  processMovieData(movie) {
    // 处理后的数据
    const movieData = {};
    // 处理导演和演员数组
    movieData.directorsStr = convertToCastString(movie.directors);
    movieData.castsStr = convertToCastString(movie.casts);
    // 图片处理一下
    movieData.image = movie.images.large;
    // 标题处理
    movieData.title = movie.title;
    // 副标题
    movieData.sub_title = movie.countries[0] + " · " + movie.year;
    movieData.wishCount = movie.wish_count;
    movieData.commentsCount = movie.comments_count;
    movieData.originalTitle = movie.original_title;
    // 评分
    movieData.score = movie.rating.stars / 10;
    movieData.average = movie.rating.average;
    movieData.genresStr = movie.genres.join(" / ");
    movieData.summary = movie.summary;
    // 处理影人数据
    movieData.castsInfo = convertToCastInfos(movie.casts);
    // 数据绑定
    this.setData({
      movie: movieData
    })
  },
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {

  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {

  }
})
```



### 入门篇完结



小程序相对于vue或者react来说还是比较简单的。入门容易。



### 完整项目代码

**完整项目代码放在csdn博客上，也可以去我的github上下载。**



### github地址

[first_mini_program](https://github.com/maolovecoding/first_mini_program)

